// Code generated by ogen, DO NOT EDIT.

package cbnsapi

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

// Encode encodes AddressFamily as json.
func (s AddressFamily) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AddressFamily from json.
func (s *AddressFamily) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddressFamily to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AddressFamily(v) {
	case AddressFamilyInet:
		*s = AddressFamilyInet
	case AddressFamilyInet6:
		*s = AddressFamilyInet6
	default:
		*s = AddressFamily(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddressFamily) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddressFamily) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthType as json.
func (s AuthType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AuthType from json.
func (s *AuthType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuthType(v) {
	case AuthTypeSasl:
		*s = AuthTypeSasl
	default:
		*s = AuthType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BucketCapability as json.
func (s BucketCapability) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BucketCapability from json.
func (s *BucketCapability) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BucketCapability to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BucketCapability(v) {
	case BucketCapabilityCollections:
		*s = BucketCapabilityCollections
	case BucketCapabilityDurableWrite:
		*s = BucketCapabilityDurableWrite
	case BucketCapabilityTombstonedUserXAttrs:
		*s = BucketCapabilityTombstonedUserXAttrs
	case BucketCapabilityCouchapi:
		*s = BucketCapabilityCouchapi
	case BucketCapabilitySubdocReplaceBodyWithXattr:
		*s = BucketCapabilitySubdocReplaceBodyWithXattr
	case BucketCapabilitySubdocDocumentMacroSupport:
		*s = BucketCapabilitySubdocDocumentMacroSupport
	case BucketCapabilitySubdocReviveDocument:
		*s = BucketCapabilitySubdocReviveDocument
	case BucketCapabilityDcpIgnorePurgedTombstones:
		*s = BucketCapabilityDcpIgnorePurgedTombstones
	case BucketCapabilityDcp:
		*s = BucketCapabilityDcp
	case BucketCapabilityCbhello:
		*s = BucketCapabilityCbhello
	case BucketCapabilityTouch:
		*s = BucketCapabilityTouch
	case BucketCapabilityCccp:
		*s = BucketCapabilityCccp
	case BucketCapabilityXdcrCheckpointing:
		*s = BucketCapabilityXdcrCheckpointing
	case BucketCapabilityNodesExt:
		*s = BucketCapabilityNodesExt
	case BucketCapabilityXattr:
		*s = BucketCapabilityXattr
	default:
		*s = BucketCapability(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BucketCapability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BucketCapability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BucketInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BucketInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("nodeLocator")
		s.NodeLocator.Encode(e)
	}
	{
		e.FieldStart("bucketType")
		s.BucketType.Encode(e)
	}
	{
		e.FieldStart("storageBackend")
		s.StorageBackend.Encode(e)
	}
	{
		e.FieldStart("uuid")
		e.Str(s.UUID)
	}
	{
		e.FieldStart("uri")
		e.Str(s.URI)
	}
	{
		e.FieldStart("streamingUri")
		e.Str(s.StreamingUri)
	}
	{
		e.FieldStart("bucketCapabilitiesVer")
		e.Str(s.BucketCapabilitiesVer)
	}
	{
		e.FieldStart("bucketCapabilities")
		e.ArrStart()
		for _, elem := range s.BucketCapabilities {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("collectionManifestUid")
		e.Str(s.CollectionManifestUid)
	}
	{
		e.FieldStart("ddocs")
		s.Ddocs.Encode(e)
	}
	{
		if s.VBucketServerMap.Set {
			e.FieldStart("vBucketServerMap")
			s.VBucketServerMap.Encode(e)
		}
	}
	{
		e.FieldStart("localRandomKeyUri")
		e.Str(s.LocalRandomKeyUri)
	}
	{
		e.FieldStart("controllers")
		s.Controllers.Encode(e)
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("stats")
		s.Stats.Encode(e)
	}
	{
		e.FieldStart("authType")
		s.AuthType.Encode(e)
	}
	{
		e.FieldStart("autoCompactionSettings")
		s.AutoCompactionSettings.Encode(e)
	}
	{
		e.FieldStart("replicaIndex")
		e.Bool(s.ReplicaIndex)
	}
	{
		e.FieldStart("replicaNumber")
		e.Int(s.ReplicaNumber)
	}
	{
		e.FieldStart("threadsNumber")
		e.Int(s.ThreadsNumber)
	}
	{
		e.FieldStart("quota")
		s.Quota.Encode(e)
	}
	{
		e.FieldStart("basicStats")
		s.BasicStats.Encode(e)
	}
	{
		e.FieldStart("evictionPolicy")
		s.EvictionPolicy.Encode(e)
	}
	{
		if s.DurabilityMinLevel.Set {
			e.FieldStart("durabilityMinLevel")
			s.DurabilityMinLevel.Encode(e)
		}
	}
	{
		if s.PitrEnabled.Set {
			e.FieldStart("pitrEnabled")
			s.PitrEnabled.Encode(e)
		}
	}
	{
		if s.PitrGranularity.Set {
			e.FieldStart("pitrGranularity")
			s.PitrGranularity.Encode(e)
		}
	}
	{
		if s.PitrMaxHistoryAge.Set {
			e.FieldStart("pitrMaxHistoryAge")
			s.PitrMaxHistoryAge.Encode(e)
		}
	}
	{
		if s.ConflictResolutionType.Set {
			e.FieldStart("conflictResolutionType")
			s.ConflictResolutionType.Encode(e)
		}
	}
	{
		if s.MaxTTL.Set {
			e.FieldStart("maxTTL")
			s.MaxTTL.Encode(e)
		}
	}
	{
		if s.CompressionMode.Set {
			e.FieldStart("compressionMode")
			s.CompressionMode.Encode(e)
		}
	}
}

var jsonFieldsNameOfBucketInfo = [31]string{
	0:  "name",
	1:  "nodeLocator",
	2:  "bucketType",
	3:  "storageBackend",
	4:  "uuid",
	5:  "uri",
	6:  "streamingUri",
	7:  "bucketCapabilitiesVer",
	8:  "bucketCapabilities",
	9:  "collectionManifestUid",
	10: "ddocs",
	11: "vBucketServerMap",
	12: "localRandomKeyUri",
	13: "controllers",
	14: "nodes",
	15: "stats",
	16: "authType",
	17: "autoCompactionSettings",
	18: "replicaIndex",
	19: "replicaNumber",
	20: "threadsNumber",
	21: "quota",
	22: "basicStats",
	23: "evictionPolicy",
	24: "durabilityMinLevel",
	25: "pitrEnabled",
	26: "pitrGranularity",
	27: "pitrMaxHistoryAge",
	28: "conflictResolutionType",
	29: "maxTTL",
	30: "compressionMode",
}

// Decode decodes BucketInfo from json.
func (s *BucketInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BucketInfo to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "nodeLocator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.NodeLocator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeLocator\"")
			}
		case "bucketType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.BucketType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bucketType\"")
			}
		case "storageBackend":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.StorageBackend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageBackend\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.UUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "uri":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.URI = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "streamingUri":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.StreamingUri = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"streamingUri\"")
			}
		case "bucketCapabilitiesVer":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.BucketCapabilitiesVer = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bucketCapabilitiesVer\"")
			}
		case "bucketCapabilities":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.BucketCapabilities = make([]BucketCapability, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BucketCapability
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BucketCapabilities = append(s.BucketCapabilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bucketCapabilities\"")
			}
		case "collectionManifestUid":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.CollectionManifestUid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collectionManifestUid\"")
			}
		case "ddocs":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.Ddocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ddocs\"")
			}
		case "vBucketServerMap":
			if err := func() error {
				s.VBucketServerMap.Reset()
				if err := s.VBucketServerMap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vBucketServerMap\"")
			}
		case "localRandomKeyUri":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LocalRandomKeyUri = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"localRandomKeyUri\"")
			}
		case "controllers":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Controllers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"controllers\"")
			}
		case "nodes":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				s.Nodes = make([]NodeInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodeInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "stats":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		case "authType":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.AuthType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authType\"")
			}
		case "autoCompactionSettings":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.AutoCompactionSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autoCompactionSettings\"")
			}
		case "replicaIndex":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.ReplicaIndex = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicaIndex\"")
			}
		case "replicaNumber":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ReplicaNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replicaNumber\"")
			}
		case "threadsNumber":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ThreadsNumber = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"threadsNumber\"")
			}
		case "quota":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.Quota.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quota\"")
			}
		case "basicStats":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.BasicStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"basicStats\"")
			}
		case "evictionPolicy":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.EvictionPolicy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evictionPolicy\"")
			}
		case "durabilityMinLevel":
			if err := func() error {
				s.DurabilityMinLevel.Reset()
				if err := s.DurabilityMinLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"durabilityMinLevel\"")
			}
		case "pitrEnabled":
			if err := func() error {
				s.PitrEnabled.Reset()
				if err := s.PitrEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pitrEnabled\"")
			}
		case "pitrGranularity":
			if err := func() error {
				s.PitrGranularity.Reset()
				if err := s.PitrGranularity.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pitrGranularity\"")
			}
		case "pitrMaxHistoryAge":
			if err := func() error {
				s.PitrMaxHistoryAge.Reset()
				if err := s.PitrMaxHistoryAge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pitrMaxHistoryAge\"")
			}
		case "conflictResolutionType":
			if err := func() error {
				s.ConflictResolutionType.Reset()
				if err := s.ConflictResolutionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conflictResolutionType\"")
			}
		case "maxTTL":
			if err := func() error {
				s.MaxTTL.Reset()
				if err := s.MaxTTL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxTTL\"")
			}
		case "compressionMode":
			if err := func() error {
				s.CompressionMode.Reset()
				if err := s.CompressionMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compressionMode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BucketInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11110111,
		0b11111111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBucketInfo) {
					name = jsonFieldsNameOfBucketInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BucketInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BucketInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BucketInfoAutoCompactionSettings as json.
func (s BucketInfoAutoCompactionSettings) Encode(e *jx.Encoder) {
	switch s.Type {
	case BoolBucketInfoAutoCompactionSettings:
		e.Bool(s.Bool)
	case BucketInfoAutoCompactionSettings1BucketInfoAutoCompactionSettings:
		s.BucketInfoAutoCompactionSettings1.Encode(e)
	}
}

// Decode decodes BucketInfoAutoCompactionSettings from json.
func (s *BucketInfoAutoCompactionSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BucketInfoAutoCompactionSettings to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolBucketInfoAutoCompactionSettings
	case jx.Object:
		if err := s.BucketInfoAutoCompactionSettings1.Decode(d); err != nil {
			return err
		}
		s.Type = BucketInfoAutoCompactionSettings1BucketInfoAutoCompactionSettings
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BucketInfoAutoCompactionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BucketInfoAutoCompactionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BucketInfoAutoCompactionSettings1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BucketInfoAutoCompactionSettings1) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfBucketInfoAutoCompactionSettings1 = [0]string{}

// Decode decodes BucketInfoAutoCompactionSettings1 from json.
func (s *BucketInfoAutoCompactionSettings1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BucketInfoAutoCompactionSettings1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode BucketInfoAutoCompactionSettings1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BucketInfoAutoCompactionSettings1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BucketInfoAutoCompactionSettings1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s BucketInfoBasicStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s BucketInfoBasicStats) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int(elem)
	}
}

// Decode decodes BucketInfoBasicStats from json.
func (s *BucketInfoBasicStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BucketInfoBasicStats to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int
		if err := func() error {
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BucketInfoBasicStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BucketInfoBasicStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BucketInfoBasicStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BucketInfoCompressionMode as json.
func (s BucketInfoCompressionMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BucketInfoCompressionMode from json.
func (s *BucketInfoCompressionMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BucketInfoCompressionMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BucketInfoCompressionMode(v) {
	case BucketInfoCompressionModePassive:
		*s = BucketInfoCompressionModePassive
	default:
		*s = BucketInfoCompressionMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BucketInfoCompressionMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BucketInfoCompressionMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BucketInfoConflictResolutionType as json.
func (s BucketInfoConflictResolutionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BucketInfoConflictResolutionType from json.
func (s *BucketInfoConflictResolutionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BucketInfoConflictResolutionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BucketInfoConflictResolutionType(v) {
	case BucketInfoConflictResolutionTypeSeqno:
		*s = BucketInfoConflictResolutionTypeSeqno
	default:
		*s = BucketInfoConflictResolutionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BucketInfoConflictResolutionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BucketInfoConflictResolutionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BucketInfoControllers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BucketInfoControllers) encodeFields(e *jx.Encoder) {
	{
		if s.CompactAll.Set {
			e.FieldStart("compactAll")
			s.CompactAll.Encode(e)
		}
	}
	{
		if s.CompactDB.Set {
			e.FieldStart("compactDB")
			s.CompactDB.Encode(e)
		}
	}
	{
		if s.PurgeDeletes.Set {
			e.FieldStart("purgeDeletes")
			s.PurgeDeletes.Encode(e)
		}
	}
	{
		if s.StartRecovery.Set {
			e.FieldStart("startRecovery")
			s.StartRecovery.Encode(e)
		}
	}
	{
		if s.Flush.Set {
			e.FieldStart("flush")
			s.Flush.Encode(e)
		}
	}
}

var jsonFieldsNameOfBucketInfoControllers = [5]string{
	0: "compactAll",
	1: "compactDB",
	2: "purgeDeletes",
	3: "startRecovery",
	4: "flush",
}

// Decode decodes BucketInfoControllers from json.
func (s *BucketInfoControllers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BucketInfoControllers to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "compactAll":
			if err := func() error {
				s.CompactAll.Reset()
				if err := s.CompactAll.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compactAll\"")
			}
		case "compactDB":
			if err := func() error {
				s.CompactDB.Reset()
				if err := s.CompactDB.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"compactDB\"")
			}
		case "purgeDeletes":
			if err := func() error {
				s.PurgeDeletes.Reset()
				if err := s.PurgeDeletes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"purgeDeletes\"")
			}
		case "startRecovery":
			if err := func() error {
				s.StartRecovery.Reset()
				if err := s.StartRecovery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startRecovery\"")
			}
		case "flush":
			if err := func() error {
				s.Flush.Reset()
				if err := s.Flush.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flush\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BucketInfoControllers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BucketInfoControllers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BucketInfoControllers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BucketInfoDdocs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BucketInfoDdocs) encodeFields(e *jx.Encoder) {
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfBucketInfoDdocs = [1]string{
	0: "uri",
}

// Decode decodes BucketInfoDdocs from json.
func (s *BucketInfoDdocs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BucketInfoDdocs to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BucketInfoDdocs")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BucketInfoDdocs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BucketInfoDdocs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BucketInfoDurabilityMinLevel as json.
func (s BucketInfoDurabilityMinLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BucketInfoDurabilityMinLevel from json.
func (s *BucketInfoDurabilityMinLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BucketInfoDurabilityMinLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BucketInfoDurabilityMinLevel(v) {
	case BucketInfoDurabilityMinLevelNone:
		*s = BucketInfoDurabilityMinLevelNone
	default:
		*s = BucketInfoDurabilityMinLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BucketInfoDurabilityMinLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BucketInfoDurabilityMinLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BucketInfoEvictionPolicy as json.
func (s BucketInfoEvictionPolicy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BucketInfoEvictionPolicy from json.
func (s *BucketInfoEvictionPolicy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BucketInfoEvictionPolicy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BucketInfoEvictionPolicy(v) {
	case BucketInfoEvictionPolicyValueOnly:
		*s = BucketInfoEvictionPolicyValueOnly
	default:
		*s = BucketInfoEvictionPolicy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BucketInfoEvictionPolicy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BucketInfoEvictionPolicy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BucketInfoQuota) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BucketInfoQuota) encodeFields(e *jx.Encoder) {
	{
		if s.RAM.Set {
			e.FieldStart("ram")
			s.RAM.Encode(e)
		}
	}
	{
		if s.RawRAM.Set {
			e.FieldStart("rawRAM")
			s.RawRAM.Encode(e)
		}
	}
}

var jsonFieldsNameOfBucketInfoQuota = [2]string{
	0: "ram",
	1: "rawRAM",
}

// Decode decodes BucketInfoQuota from json.
func (s *BucketInfoQuota) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BucketInfoQuota to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ram":
			if err := func() error {
				s.RAM.Reset()
				if err := s.RAM.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ram\"")
			}
		case "rawRAM":
			if err := func() error {
				s.RawRAM.Reset()
				if err := s.RawRAM.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawRAM\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BucketInfoQuota")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BucketInfoQuota) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BucketInfoQuota) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BucketInfoStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BucketInfoStats) encodeFields(e *jx.Encoder) {
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.DirectoryURI.Set {
			e.FieldStart("directoryURI")
			s.DirectoryURI.Encode(e)
		}
	}
	{
		if s.NodeStatsListURI.Set {
			e.FieldStart("nodeStatsListURI")
			s.NodeStatsListURI.Encode(e)
		}
	}
}

var jsonFieldsNameOfBucketInfoStats = [3]string{
	0: "uri",
	1: "directoryURI",
	2: "nodeStatsListURI",
}

// Decode decodes BucketInfoStats from json.
func (s *BucketInfoStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BucketInfoStats to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "directoryURI":
			if err := func() error {
				s.DirectoryURI.Reset()
				if err := s.DirectoryURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"directoryURI\"")
			}
		case "nodeStatsListURI":
			if err := func() error {
				s.NodeStatsListURI.Reset()
				if err := s.NodeStatsListURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeStatsListURI\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BucketInfoStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BucketInfoStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BucketInfoStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BucketType as json.
func (s BucketType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BucketType from json.
func (s *BucketType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BucketType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BucketType(v) {
	case BucketTypeMembase:
		*s = BucketTypeMembase
	case BucketTypeMemcached:
		*s = BucketTypeMemcached
	default:
		*s = BucketType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BucketType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BucketType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BucketsInfo as json.
func (s BucketsInfo) Encode(e *jx.Encoder) {
	unwrapped := []BucketInfo(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes BucketsInfo from json.
func (s *BucketsInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BucketsInfo to nil")
	}
	var unwrapped []BucketInfo
	if err := func() error {
		unwrapped = make([]BucketInfo, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem BucketInfo
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = BucketsInfo(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BucketsInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BucketsInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ClusterCapabilities) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ClusterCapabilities) encodeFields(e *jx.Encoder) {
	{
		if s.N1ql != nil {
			e.FieldStart("n1ql")
			e.ArrStart()
			for _, elem := range s.N1ql {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfClusterCapabilities = [1]string{
	0: "n1ql",
}

// Decode decodes ClusterCapabilities from json.
func (s *ClusterCapabilities) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterCapabilities to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "n1ql":
			if err := func() error {
				s.N1ql = make([]N1qlClusterCapability, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem N1qlClusterCapability
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.N1ql = append(s.N1ql, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"n1ql\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ClusterCapabilities")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ClusterCapabilities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterCapabilities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClusterCapabilitiesVersion as json.
func (s ClusterCapabilitiesVersion) Encode(e *jx.Encoder) {
	unwrapped := []int(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		e.Int(elem)
	}
	e.ArrEnd()
}

// Decode decodes ClusterCapabilitiesVersion from json.
func (s *ClusterCapabilitiesVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ClusterCapabilitiesVersion to nil")
	}
	var unwrapped []int
	if err := func() error {
		unwrapped = make([]int, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem int
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ClusterCapabilitiesVersion(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ClusterCapabilitiesVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ClusterCapabilitiesVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes N1qlClusterCapability as json.
func (s N1qlClusterCapability) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes N1qlClusterCapability from json.
func (s *N1qlClusterCapability) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode N1qlClusterCapability to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch N1qlClusterCapability(v) {
	case N1qlClusterCapabilityEnhancedPreparedStatements:
		*s = N1qlClusterCapabilityEnhancedPreparedStatements
	default:
		*s = N1qlClusterCapability(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s N1qlClusterCapability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *N1qlClusterCapability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodeInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodeInfo) encodeFields(e *jx.Encoder) {
	{
		if s.ClusterMembership.Set {
			e.FieldStart("clusterMembership")
			s.ClusterMembership.Encode(e)
		}
	}
	{
		if s.RecoveryType.Set {
			e.FieldStart("recoveryType")
			s.RecoveryType.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.OtpNode.Set {
			e.FieldStart("otpNode")
			s.OtpNode.Encode(e)
		}
	}
	{
		if s.ThisNode.Set {
			e.FieldStart("thisNode")
			s.ThisNode.Encode(e)
		}
	}
	{
		if s.Hostname.Set {
			e.FieldStart("hostname")
			s.Hostname.Encode(e)
		}
	}
	{
		if s.NodeUUID.Set {
			e.FieldStart("nodeUUID")
			s.NodeUUID.Encode(e)
		}
	}
	{
		if s.ClusterCompatibility.Set {
			e.FieldStart("clusterCompatibility")
			s.ClusterCompatibility.Encode(e)
		}
	}
	{
		if s.Version.Set {
			e.FieldStart("version")
			s.Version.Encode(e)
		}
	}
	{
		if s.Os.Set {
			e.FieldStart("os")
			s.Os.Encode(e)
		}
	}
	{
		if s.CpuCount.Set {
			e.FieldStart("cpuCount")
			s.CpuCount.Encode(e)
		}
	}
	{
		if s.Ports.Set {
			e.FieldStart("ports")
			s.Ports.Encode(e)
		}
	}
	{
		if s.Services != nil {
			e.FieldStart("services")
			e.ArrStart()
			for _, elem := range s.Services {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NodeEncryption.Set {
			e.FieldStart("nodeEncryption")
			s.NodeEncryption.Encode(e)
		}
	}
	{
		if s.AddressFamilyOnly.Set {
			e.FieldStart("addressFamilyOnly")
			s.AddressFamilyOnly.Encode(e)
		}
	}
	{
		if s.ConfiguredHostname.Set {
			e.FieldStart("configuredHostname")
			s.ConfiguredHostname.Encode(e)
		}
	}
	{
		if s.AddressFamily.Set {
			e.FieldStart("addressFamily")
			s.AddressFamily.Encode(e)
		}
	}
	{
		if s.ExternalListeners != nil {
			e.FieldStart("externalListeners")
			e.ArrStart()
			for _, elem := range s.ExternalListeners {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ServerGroup.Set {
			e.FieldStart("serverGroup")
			s.ServerGroup.Encode(e)
		}
	}
	{
		if s.CouchApiBase.Set {
			e.FieldStart("couchApiBase")
			s.CouchApiBase.Encode(e)
		}
	}
	{
		if s.CouchApiBaseHTTPS.Set {
			e.FieldStart("couchApiBaseHTTPS")
			s.CouchApiBaseHTTPS.Encode(e)
		}
	}
	{
		if s.NodeHash.Set {
			e.FieldStart("nodeHash")
			s.NodeHash.Encode(e)
		}
	}
	{
		if s.SystemStats.Set {
			e.FieldStart("systemStats")
			s.SystemStats.Encode(e)
		}
	}
	{
		if s.InterestingStats.Set {
			e.FieldStart("interestingStats")
			s.InterestingStats.Encode(e)
		}
	}
	{
		if s.Uptime.Set {
			e.FieldStart("uptime")
			s.Uptime.Encode(e)
		}
	}
	{
		if s.MemoryTotal.Set {
			e.FieldStart("memoryTotal")
			s.MemoryTotal.Encode(e)
		}
	}
	{
		if s.MemoryFree.Set {
			e.FieldStart("memoryFree")
			s.MemoryFree.Encode(e)
		}
	}
	{
		if s.McdMemoryReserved.Set {
			e.FieldStart("mcdMemoryReserved")
			s.McdMemoryReserved.Encode(e)
		}
	}
	{
		if s.McdMemoryAllocated.Set {
			e.FieldStart("mcdMemoryAllocated")
			s.McdMemoryAllocated.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodeInfo = [29]string{
	0:  "clusterMembership",
	1:  "recoveryType",
	2:  "status",
	3:  "otpNode",
	4:  "thisNode",
	5:  "hostname",
	6:  "nodeUUID",
	7:  "clusterCompatibility",
	8:  "version",
	9:  "os",
	10: "cpuCount",
	11: "ports",
	12: "services",
	13: "nodeEncryption",
	14: "addressFamilyOnly",
	15: "configuredHostname",
	16: "addressFamily",
	17: "externalListeners",
	18: "serverGroup",
	19: "couchApiBase",
	20: "couchApiBaseHTTPS",
	21: "nodeHash",
	22: "systemStats",
	23: "interestingStats",
	24: "uptime",
	25: "memoryTotal",
	26: "memoryFree",
	27: "mcdMemoryReserved",
	28: "mcdMemoryAllocated",
}

// Decode decodes NodeInfo from json.
func (s *NodeInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clusterMembership":
			if err := func() error {
				s.ClusterMembership.Reset()
				if err := s.ClusterMembership.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterMembership\"")
			}
		case "recoveryType":
			if err := func() error {
				s.RecoveryType.Reset()
				if err := s.RecoveryType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"recoveryType\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "otpNode":
			if err := func() error {
				s.OtpNode.Reset()
				if err := s.OtpNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"otpNode\"")
			}
		case "thisNode":
			if err := func() error {
				s.ThisNode.Reset()
				if err := s.ThisNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thisNode\"")
			}
		case "hostname":
			if err := func() error {
				s.Hostname.Reset()
				if err := s.Hostname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		case "nodeUUID":
			if err := func() error {
				s.NodeUUID.Reset()
				if err := s.NodeUUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUUID\"")
			}
		case "clusterCompatibility":
			if err := func() error {
				s.ClusterCompatibility.Reset()
				if err := s.ClusterCompatibility.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterCompatibility\"")
			}
		case "version":
			if err := func() error {
				s.Version.Reset()
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "os":
			if err := func() error {
				s.Os.Reset()
				if err := s.Os.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"os\"")
			}
		case "cpuCount":
			if err := func() error {
				s.CpuCount.Reset()
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "ports":
			if err := func() error {
				s.Ports.Reset()
				if err := s.Ports.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		case "services":
			if err := func() error {
				s.Services = make([]Service, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Service
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Services = append(s.Services, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"services\"")
			}
		case "nodeEncryption":
			if err := func() error {
				s.NodeEncryption.Reset()
				if err := s.NodeEncryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeEncryption\"")
			}
		case "addressFamilyOnly":
			if err := func() error {
				s.AddressFamilyOnly.Reset()
				if err := s.AddressFamilyOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addressFamilyOnly\"")
			}
		case "configuredHostname":
			if err := func() error {
				s.ConfiguredHostname.Reset()
				if err := s.ConfiguredHostname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configuredHostname\"")
			}
		case "addressFamily":
			if err := func() error {
				s.AddressFamily.Reset()
				if err := s.AddressFamily.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addressFamily\"")
			}
		case "externalListeners":
			if err := func() error {
				s.ExternalListeners = make([]NodeInfoExternalListenersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodeInfoExternalListenersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExternalListeners = append(s.ExternalListeners, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalListeners\"")
			}
		case "serverGroup":
			if err := func() error {
				s.ServerGroup.Reset()
				if err := s.ServerGroup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverGroup\"")
			}
		case "couchApiBase":
			if err := func() error {
				s.CouchApiBase.Reset()
				if err := s.CouchApiBase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"couchApiBase\"")
			}
		case "couchApiBaseHTTPS":
			if err := func() error {
				s.CouchApiBaseHTTPS.Reset()
				if err := s.CouchApiBaseHTTPS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"couchApiBaseHTTPS\"")
			}
		case "nodeHash":
			if err := func() error {
				s.NodeHash.Reset()
				if err := s.NodeHash.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeHash\"")
			}
		case "systemStats":
			if err := func() error {
				s.SystemStats.Reset()
				if err := s.SystemStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"systemStats\"")
			}
		case "interestingStats":
			if err := func() error {
				s.InterestingStats.Reset()
				if err := s.InterestingStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interestingStats\"")
			}
		case "uptime":
			if err := func() error {
				s.Uptime.Reset()
				if err := s.Uptime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime\"")
			}
		case "memoryTotal":
			if err := func() error {
				s.MemoryTotal.Reset()
				if err := s.MemoryTotal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memoryTotal\"")
			}
		case "memoryFree":
			if err := func() error {
				s.MemoryFree.Reset()
				if err := s.MemoryFree.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memoryFree\"")
			}
		case "mcdMemoryReserved":
			if err := func() error {
				s.McdMemoryReserved.Reset()
				if err := s.McdMemoryReserved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mcdMemoryReserved\"")
			}
		case "mcdMemoryAllocated":
			if err := func() error {
				s.McdMemoryAllocated.Reset()
				if err := s.McdMemoryAllocated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mcdMemoryAllocated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodeInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeInfoClusterMembership as json.
func (s NodeInfoClusterMembership) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NodeInfoClusterMembership from json.
func (s *NodeInfoClusterMembership) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeInfoClusterMembership to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NodeInfoClusterMembership(v) {
	case NodeInfoClusterMembershipActive:
		*s = NodeInfoClusterMembershipActive
	default:
		*s = NodeInfoClusterMembership(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NodeInfoClusterMembership) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeInfoClusterMembership) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodeInfoExternalListenersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodeInfoExternalListenersItem) encodeFields(e *jx.Encoder) {
	{
		if s.Afamily.Set {
			e.FieldStart("afamily")
			s.Afamily.Encode(e)
		}
	}
	{
		if s.NodeEncryption.Set {
			e.FieldStart("nodeEncryption")
			s.NodeEncryption.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodeInfoExternalListenersItem = [2]string{
	0: "afamily",
	1: "nodeEncryption",
}

// Decode decodes NodeInfoExternalListenersItem from json.
func (s *NodeInfoExternalListenersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeInfoExternalListenersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "afamily":
			if err := func() error {
				s.Afamily.Reset()
				if err := s.Afamily.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"afamily\"")
			}
		case "nodeEncryption":
			if err := func() error {
				s.NodeEncryption.Reset()
				if err := s.NodeEncryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeEncryption\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeInfoExternalListenersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodeInfoExternalListenersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeInfoExternalListenersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s NodeInfoInterestingStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s NodeInfoInterestingStats) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int(elem)
	}
}

// Decode decodes NodeInfoInterestingStats from json.
func (s *NodeInfoInterestingStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeInfoInterestingStats to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int
		if err := func() error {
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeInfoInterestingStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NodeInfoInterestingStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeInfoInterestingStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodeInfoPorts) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodeInfoPorts) encodeFields(e *jx.Encoder) {
	{
		if s.Direct.Set {
			e.FieldStart("direct")
			s.Direct.Encode(e)
		}
	}
	{
		if s.HttpsCAPI.Set {
			e.FieldStart("httpsCAPI")
			s.HttpsCAPI.Encode(e)
		}
	}
	{
		if s.HttpsMgmt.Set {
			e.FieldStart("httpsMgmt")
			s.HttpsMgmt.Encode(e)
		}
	}
	{
		if s.DistTCP.Set {
			e.FieldStart("distTCP")
			s.DistTCP.Encode(e)
		}
	}
	{
		if s.DistTLS.Set {
			e.FieldStart("distTLS")
			s.DistTLS.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodeInfoPorts = [5]string{
	0: "direct",
	1: "httpsCAPI",
	2: "httpsMgmt",
	3: "distTCP",
	4: "distTLS",
}

// Decode decodes NodeInfoPorts from json.
func (s *NodeInfoPorts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeInfoPorts to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "direct":
			if err := func() error {
				s.Direct.Reset()
				if err := s.Direct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direct\"")
			}
		case "httpsCAPI":
			if err := func() error {
				s.HttpsCAPI.Reset()
				if err := s.HttpsCAPI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpsCAPI\"")
			}
		case "httpsMgmt":
			if err := func() error {
				s.HttpsMgmt.Reset()
				if err := s.HttpsMgmt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpsMgmt\"")
			}
		case "distTCP":
			if err := func() error {
				s.DistTCP.Reset()
				if err := s.DistTCP.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"distTCP\"")
			}
		case "distTLS":
			if err := func() error {
				s.DistTLS.Reset()
				if err := s.DistTLS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"distTLS\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeInfoPorts")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodeInfoPorts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeInfoPorts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeInfoRecoveryType as json.
func (s NodeInfoRecoveryType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NodeInfoRecoveryType from json.
func (s *NodeInfoRecoveryType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeInfoRecoveryType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NodeInfoRecoveryType(v) {
	case NodeInfoRecoveryTypeNone:
		*s = NodeInfoRecoveryTypeNone
	default:
		*s = NodeInfoRecoveryType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NodeInfoRecoveryType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeInfoRecoveryType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeInfoStatus as json.
func (s NodeInfoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NodeInfoStatus from json.
func (s *NodeInfoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeInfoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NodeInfoStatus(v) {
	case NodeInfoStatusHealthy:
		*s = NodeInfoStatusHealthy
	default:
		*s = NodeInfoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NodeInfoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeInfoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s NodeInfoSystemStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s NodeInfoSystemStats) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Int(elem)
	}
}

// Decode decodes NodeInfoSystemStats from json.
func (s *NodeInfoSystemStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeInfoSystemStats to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem int
		if err := func() error {
			v, err := d.Int()
			elem = int(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeInfoSystemStats")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NodeInfoSystemStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeInfoSystemStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeLocator as json.
func (s NodeLocator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NodeLocator from json.
func (s *NodeLocator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeLocator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NodeLocator(v) {
	case NodeLocatorVbucket:
		*s = NodeLocatorVbucket
	case NodeLocatorKetama:
		*s = NodeLocatorKetama
	default:
		*s = NodeLocator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NodeLocator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeLocator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodeServices) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodeServices) encodeFields(e *jx.Encoder) {
	{
		if s.Rev.Set {
			e.FieldStart("rev")
			s.Rev.Encode(e)
		}
	}
	{
		if s.NodesExt != nil {
			e.FieldStart("nodesExt")
			e.ArrStart()
			for _, elem := range s.NodesExt {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ClusterCapabilitiesVer != nil {
			e.FieldStart("clusterCapabilitiesVer")
			s.ClusterCapabilitiesVer.Encode(e)
		}
	}
	{
		if s.ClusterCapabilities.Set {
			e.FieldStart("clusterCapabilities")
			s.ClusterCapabilities.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodeServices = [4]string{
	0: "rev",
	1: "nodesExt",
	2: "clusterCapabilitiesVer",
	3: "clusterCapabilities",
}

// Decode decodes NodeServices from json.
func (s *NodeServices) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodeServices to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rev":
			if err := func() error {
				s.Rev.Reset()
				if err := s.Rev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rev\"")
			}
		case "nodesExt":
			if err := func() error {
				s.NodesExt = make([]TerseNodeExtInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TerseNodeExtInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NodesExt = append(s.NodesExt, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodesExt\"")
			}
		case "clusterCapabilitiesVer":
			if err := func() error {
				if err := s.ClusterCapabilitiesVer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterCapabilitiesVer\"")
			}
		case "clusterCapabilities":
			if err := func() error {
				s.ClusterCapabilities.Reset()
				if err := s.ClusterCapabilities.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterCapabilities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodeServices")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodeServices) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodeServices) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddressFamily as json.
func (o OptAddressFamily) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes AddressFamily from json.
func (o *OptAddressFamily) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAddressFamily to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAddressFamily) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAddressFamily) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BucketInfoCompressionMode as json.
func (o OptBucketInfoCompressionMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BucketInfoCompressionMode from json.
func (o *OptBucketInfoCompressionMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBucketInfoCompressionMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBucketInfoCompressionMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBucketInfoCompressionMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BucketInfoConflictResolutionType as json.
func (o OptBucketInfoConflictResolutionType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BucketInfoConflictResolutionType from json.
func (o *OptBucketInfoConflictResolutionType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBucketInfoConflictResolutionType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBucketInfoConflictResolutionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBucketInfoConflictResolutionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BucketInfoDurabilityMinLevel as json.
func (o OptBucketInfoDurabilityMinLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BucketInfoDurabilityMinLevel from json.
func (o *OptBucketInfoDurabilityMinLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBucketInfoDurabilityMinLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBucketInfoDurabilityMinLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBucketInfoDurabilityMinLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BucketType as json.
func (o OptBucketType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BucketType from json.
func (o *OptBucketType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBucketType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBucketType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBucketType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ClusterCapabilities as json.
func (o OptClusterCapabilities) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ClusterCapabilities from json.
func (o *OptClusterCapabilities) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptClusterCapabilities to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptClusterCapabilities) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptClusterCapabilities) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeInfoClusterMembership as json.
func (o OptNodeInfoClusterMembership) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NodeInfoClusterMembership from json.
func (o *OptNodeInfoClusterMembership) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNodeInfoClusterMembership to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNodeInfoClusterMembership) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNodeInfoClusterMembership) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeInfoInterestingStats as json.
func (o OptNodeInfoInterestingStats) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NodeInfoInterestingStats from json.
func (o *OptNodeInfoInterestingStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNodeInfoInterestingStats to nil")
	}
	o.Set = true
	o.Value = make(NodeInfoInterestingStats)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNodeInfoInterestingStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNodeInfoInterestingStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeInfoPorts as json.
func (o OptNodeInfoPorts) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NodeInfoPorts from json.
func (o *OptNodeInfoPorts) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNodeInfoPorts to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNodeInfoPorts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNodeInfoPorts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeInfoRecoveryType as json.
func (o OptNodeInfoRecoveryType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NodeInfoRecoveryType from json.
func (o *OptNodeInfoRecoveryType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNodeInfoRecoveryType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNodeInfoRecoveryType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNodeInfoRecoveryType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeInfoStatus as json.
func (o OptNodeInfoStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NodeInfoStatus from json.
func (o *OptNodeInfoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNodeInfoStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNodeInfoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNodeInfoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeInfoSystemStats as json.
func (o OptNodeInfoSystemStats) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes NodeInfoSystemStats from json.
func (o *OptNodeInfoSystemStats) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNodeInfoSystemStats to nil")
	}
	o.Set = true
	o.Value = make(NodeInfoSystemStats)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNodeInfoSystemStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNodeInfoSystemStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NodeLocator as json.
func (o OptNodeLocator) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NodeLocator from json.
func (o *OptNodeLocator) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNodeLocator to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNodeLocator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNodeLocator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoAutoCompactionSettings as json.
func (o OptPoolInfoAutoCompactionSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoAutoCompactionSettings from json.
func (o *OptPoolInfoAutoCompactionSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoAutoCompactionSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoAutoCompactionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoAutoCompactionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold as json.
func (o OptPoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold from json.
func (o *OptPoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize as json.
func (o OptPoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize from json.
func (o *OptPoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoAutoCompactionSettingsIndexCircularCompaction as json.
func (o OptPoolInfoAutoCompactionSettingsIndexCircularCompaction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoAutoCompactionSettingsIndexCircularCompaction from json.
func (o *OptPoolInfoAutoCompactionSettingsIndexCircularCompaction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoAutoCompactionSettingsIndexCircularCompaction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoAutoCompactionSettingsIndexCircularCompaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoAutoCompactionSettingsIndexCircularCompaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoAutoCompactionSettingsIndexCircularCompactionInterval as json.
func (o OptPoolInfoAutoCompactionSettingsIndexCircularCompactionInterval) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoAutoCompactionSettingsIndexCircularCompactionInterval from json.
func (o *OptPoolInfoAutoCompactionSettingsIndexCircularCompactionInterval) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoAutoCompactionSettingsIndexCircularCompactionInterval to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoAutoCompactionSettingsIndexCircularCompactionInterval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoAutoCompactionSettingsIndexCircularCompactionInterval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoAutoCompactionSettingsIndexCompactionMode as json.
func (o OptPoolInfoAutoCompactionSettingsIndexCompactionMode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PoolInfoAutoCompactionSettingsIndexCompactionMode from json.
func (o *OptPoolInfoAutoCompactionSettingsIndexCompactionMode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoAutoCompactionSettingsIndexCompactionMode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoAutoCompactionSettingsIndexCompactionMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoAutoCompactionSettingsIndexCompactionMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoAutoCompactionSettingsIndexFragmentationThreshold as json.
func (o OptPoolInfoAutoCompactionSettingsIndexFragmentationThreshold) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoAutoCompactionSettingsIndexFragmentationThreshold from json.
func (o *OptPoolInfoAutoCompactionSettingsIndexFragmentationThreshold) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoAutoCompactionSettingsIndexFragmentationThreshold to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoAutoCompactionSettingsIndexFragmentationThreshold) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoAutoCompactionSettingsIndexFragmentationThreshold) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoBuckets as json.
func (o OptPoolInfoBuckets) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoBuckets from json.
func (o *OptPoolInfoBuckets) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoBuckets to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoBuckets) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoBuckets) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoClusterEncryptionLevel as json.
func (o OptPoolInfoClusterEncryptionLevel) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PoolInfoClusterEncryptionLevel from json.
func (o *OptPoolInfoClusterEncryptionLevel) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoClusterEncryptionLevel to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoClusterEncryptionLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoClusterEncryptionLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoControllers as json.
func (o OptPoolInfoControllers) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoControllers from json.
func (o *OptPoolInfoControllers) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoControllers to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoControllers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoControllers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoControllersAddNode as json.
func (o OptPoolInfoControllersAddNode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoControllersAddNode from json.
func (o *OptPoolInfoControllersAddNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoControllersAddNode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoControllersAddNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoControllersAddNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoControllersClusterLogsCollection as json.
func (o OptPoolInfoControllersClusterLogsCollection) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoControllersClusterLogsCollection from json.
func (o *OptPoolInfoControllersClusterLogsCollection) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoControllersClusterLogsCollection to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoControllersClusterLogsCollection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoControllersClusterLogsCollection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoControllersEjectNode as json.
func (o OptPoolInfoControllersEjectNode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoControllersEjectNode from json.
func (o *OptPoolInfoControllersEjectNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoControllersEjectNode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoControllersEjectNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoControllersEjectNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoControllersFailOver as json.
func (o OptPoolInfoControllersFailOver) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoControllersFailOver from json.
func (o *OptPoolInfoControllersFailOver) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoControllersFailOver to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoControllersFailOver) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoControllersFailOver) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoControllersReAddNode as json.
func (o OptPoolInfoControllersReAddNode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoControllersReAddNode from json.
func (o *OptPoolInfoControllersReAddNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoControllersReAddNode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoControllersReAddNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoControllersReAddNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoControllersReFailOver as json.
func (o OptPoolInfoControllersReFailOver) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoControllersReFailOver from json.
func (o *OptPoolInfoControllersReFailOver) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoControllersReFailOver to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoControllersReFailOver) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoControllersReFailOver) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoControllersRebalance as json.
func (o OptPoolInfoControllersRebalance) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoControllersRebalance from json.
func (o *OptPoolInfoControllersRebalance) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoControllersRebalance to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoControllersRebalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoControllersRebalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoControllersReplication as json.
func (o OptPoolInfoControllersReplication) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoControllersReplication from json.
func (o *OptPoolInfoControllersReplication) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoControllersReplication to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoControllersReplication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoControllersReplication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoControllersSetAutoCompaction as json.
func (o OptPoolInfoControllersSetAutoCompaction) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoControllersSetAutoCompaction from json.
func (o *OptPoolInfoControllersSetAutoCompaction) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoControllersSetAutoCompaction to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoControllersSetAutoCompaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoControllersSetAutoCompaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoControllersSetRecoveryType as json.
func (o OptPoolInfoControllersSetRecoveryType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoControllersSetRecoveryType from json.
func (o *OptPoolInfoControllersSetRecoveryType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoControllersSetRecoveryType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoControllersSetRecoveryType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoControllersSetRecoveryType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoControllersStartGracefulFailover as json.
func (o OptPoolInfoControllersStartGracefulFailover) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoControllersStartGracefulFailover from json.
func (o *OptPoolInfoControllersStartGracefulFailover) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoControllersStartGracefulFailover to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoControllersStartGracefulFailover) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoControllersStartGracefulFailover) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoCounters as json.
func (o OptPoolInfoCounters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoCounters from json.
func (o *OptPoolInfoCounters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoCounters to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoCounters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoCounters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoRebalanceStatus as json.
func (o OptPoolInfoRebalanceStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PoolInfoRebalanceStatus from json.
func (o *OptPoolInfoRebalanceStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoRebalanceStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoRebalanceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoRebalanceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoRemoteClusters as json.
func (o OptPoolInfoRemoteClusters) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoRemoteClusters from json.
func (o *OptPoolInfoRemoteClusters) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoRemoteClusters to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoRemoteClusters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoRemoteClusters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoStorageTotals as json.
func (o OptPoolInfoStorageTotals) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoStorageTotals from json.
func (o *OptPoolInfoStorageTotals) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoStorageTotals to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoStorageTotals) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoStorageTotals) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoStorageTotalsHdd as json.
func (o OptPoolInfoStorageTotalsHdd) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoStorageTotalsHdd from json.
func (o *OptPoolInfoStorageTotalsHdd) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoStorageTotalsHdd to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoStorageTotalsHdd) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoStorageTotalsHdd) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoStorageTotalsRAM as json.
func (o OptPoolInfoStorageTotalsRAM) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoStorageTotalsRAM from json.
func (o *OptPoolInfoStorageTotalsRAM) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoStorageTotalsRAM to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoStorageTotalsRAM) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoStorageTotalsRAM) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoTasks as json.
func (o OptPoolInfoTasks) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolInfoTasks from json.
func (o *OptPoolInfoTasks) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolInfoTasks to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolInfoTasks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolInfoTasks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolsInfoComponentsVersion as json.
func (o OptPoolsInfoComponentsVersion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolsInfoComponentsVersion from json.
func (o *OptPoolsInfoComponentsVersion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolsInfoComponentsVersion to nil")
	}
	o.Set = true
	o.Value = make(PoolsInfoComponentsVersion)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolsInfoComponentsVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolsInfoComponentsVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolsInfoSettings as json.
func (o OptPoolsInfoSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PoolsInfoSettings from json.
func (o *OptPoolsInfoSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPoolsInfoSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPoolsInfoSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPoolsInfoSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StorageBackend as json.
func (o OptStorageBackend) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes StorageBackend from json.
func (o *OptStorageBackend) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptStorageBackend to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptStorageBackend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptStorageBackend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TerseBucketInfoDdocs as json.
func (o OptTerseBucketInfoDdocs) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TerseBucketInfoDdocs from json.
func (o *OptTerseBucketInfoDdocs) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTerseBucketInfoDdocs to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTerseBucketInfoDdocs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTerseBucketInfoDdocs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TerseNodeExtInfoServices as json.
func (o OptTerseNodeExtInfoServices) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TerseNodeExtInfoServices from json.
func (o *OptTerseNodeExtInfoServices) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTerseNodeExtInfoServices to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTerseNodeExtInfoServices) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTerseNodeExtInfoServices) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TerseNodeInfoPorts as json.
func (o OptTerseNodeInfoPorts) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes TerseNodeInfoPorts from json.
func (o *OptTerseNodeInfoPorts) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTerseNodeInfoPorts to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTerseNodeInfoPorts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTerseNodeInfoPorts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VBucketServerMap as json.
func (o OptVBucketServerMap) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes VBucketServerMap from json.
func (o *OptVBucketServerMap) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVBucketServerMap to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVBucketServerMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVBucketServerMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Nodes != nil {
			e.FieldStart("nodes")
			e.ArrStart()
			for _, elem := range s.Nodes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Buckets.Set {
			e.FieldStart("buckets")
			s.Buckets.Encode(e)
		}
	}
	{
		if s.BucketNames != nil {
			e.FieldStart("bucketNames")
			e.ArrStart()
			for _, elem := range s.BucketNames {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RemoteClusters.Set {
			e.FieldStart("remoteClusters")
			s.RemoteClusters.Encode(e)
		}
	}
	{
		if s.Alerts != nil {
			e.FieldStart("alerts")
			e.ArrStart()
			for _, elem := range s.Alerts {
				if len(elem) != 0 {
					e.Raw(elem)
				}
			}
			e.ArrEnd()
		}
	}
	{
		if s.AlertsSilenceURL.Set {
			e.FieldStart("alertsSilenceURL")
			s.AlertsSilenceURL.Encode(e)
		}
	}
	{
		if s.Controllers.Set {
			e.FieldStart("controllers")
			s.Controllers.Encode(e)
		}
	}
	{
		if s.RebalanceStatus.Set {
			e.FieldStart("rebalanceStatus")
			s.RebalanceStatus.Encode(e)
		}
	}
	{
		if s.RebalanceProgressUri.Set {
			e.FieldStart("rebalanceProgressUri")
			s.RebalanceProgressUri.Encode(e)
		}
	}
	{
		if s.StopRebalanceUri.Set {
			e.FieldStart("stopRebalanceUri")
			s.StopRebalanceUri.Encode(e)
		}
	}
	{
		if s.NodeStatusesUri.Set {
			e.FieldStart("nodeStatusesUri")
			s.NodeStatusesUri.Encode(e)
		}
	}
	{
		if s.NodeServicesUri.Set {
			e.FieldStart("nodeServicesUri")
			s.NodeServicesUri.Encode(e)
		}
	}
	{
		if s.MaxBucketCount.Set {
			e.FieldStart("maxBucketCount")
			s.MaxBucketCount.Encode(e)
		}
	}
	{
		if s.MaxCollectionCount.Set {
			e.FieldStart("maxCollectionCount")
			s.MaxCollectionCount.Encode(e)
		}
	}
	{
		if s.MaxScopeCount.Set {
			e.FieldStart("maxScopeCount")
			s.MaxScopeCount.Encode(e)
		}
	}
	{
		if s.AutoCompactionSettings.Set {
			e.FieldStart("autoCompactionSettings")
			s.AutoCompactionSettings.Encode(e)
		}
	}
	{
		if s.Tasks.Set {
			e.FieldStart("tasks")
			s.Tasks.Encode(e)
		}
	}
	{
		if s.Counters.Set {
			e.FieldStart("counters")
			s.Counters.Encode(e)
		}
	}
	{
		if s.IndexStatusURI.Set {
			e.FieldStart("indexStatusURI")
			s.IndexStatusURI.Encode(e)
		}
	}
	{
		if s.TrustedCAsURI.Set {
			e.FieldStart("trustedCAsURI")
			s.TrustedCAsURI.Encode(e)
		}
	}
	{
		if s.ClusterName.Set {
			e.FieldStart("clusterName")
			s.ClusterName.Encode(e)
		}
	}
	{
		if s.ClusterEncryptionLevel.Set {
			e.FieldStart("clusterEncryptionLevel")
			s.ClusterEncryptionLevel.Encode(e)
		}
	}
	{
		if s.Balanced.Set {
			e.FieldStart("balanced")
			s.Balanced.Encode(e)
		}
	}
	{
		if s.CheckPermissionsURI.Set {
			e.FieldStart("checkPermissionsURI")
			s.CheckPermissionsURI.Encode(e)
		}
	}
	{
		if s.MemoryQuota.Set {
			e.FieldStart("memoryQuota")
			s.MemoryQuota.Encode(e)
		}
	}
	{
		if s.IndexMemoryQuota.Set {
			e.FieldStart("indexMemoryQuota")
			s.IndexMemoryQuota.Encode(e)
		}
	}
	{
		if s.FtsMemoryQuota.Set {
			e.FieldStart("ftsMemoryQuota")
			s.FtsMemoryQuota.Encode(e)
		}
	}
	{
		if s.CbasMemoryQuota.Set {
			e.FieldStart("cbasMemoryQuota")
			s.CbasMemoryQuota.Encode(e)
		}
	}
	{
		if s.EventingMemoryQuota.Set {
			e.FieldStart("eventingMemoryQuota")
			s.EventingMemoryQuota.Encode(e)
		}
	}
	{
		if s.StorageTotals.Set {
			e.FieldStart("storageTotals")
			s.StorageTotals.Encode(e)
		}
	}
	{
		if s.ServerGroupsUri.Set {
			e.FieldStart("serverGroupsUri")
			s.ServerGroupsUri.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfo = [32]string{
	0:  "name",
	1:  "nodes",
	2:  "buckets",
	3:  "bucketNames",
	4:  "remoteClusters",
	5:  "alerts",
	6:  "alertsSilenceURL",
	7:  "controllers",
	8:  "rebalanceStatus",
	9:  "rebalanceProgressUri",
	10: "stopRebalanceUri",
	11: "nodeStatusesUri",
	12: "nodeServicesUri",
	13: "maxBucketCount",
	14: "maxCollectionCount",
	15: "maxScopeCount",
	16: "autoCompactionSettings",
	17: "tasks",
	18: "counters",
	19: "indexStatusURI",
	20: "trustedCAsURI",
	21: "clusterName",
	22: "clusterEncryptionLevel",
	23: "balanced",
	24: "checkPermissionsURI",
	25: "memoryQuota",
	26: "indexMemoryQuota",
	27: "ftsMemoryQuota",
	28: "cbasMemoryQuota",
	29: "eventingMemoryQuota",
	30: "storageTotals",
	31: "serverGroupsUri",
}

// Decode decodes PoolInfo from json.
func (s *PoolInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "nodes":
			if err := func() error {
				s.Nodes = make([]NodeInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodeInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "buckets":
			if err := func() error {
				s.Buckets.Reset()
				if err := s.Buckets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"buckets\"")
			}
		case "bucketNames":
			if err := func() error {
				s.BucketNames = make([]PoolInfoBucketNamesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PoolInfoBucketNamesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BucketNames = append(s.BucketNames, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bucketNames\"")
			}
		case "remoteClusters":
			if err := func() error {
				s.RemoteClusters.Reset()
				if err := s.RemoteClusters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remoteClusters\"")
			}
		case "alerts":
			if err := func() error {
				s.Alerts = make([]jx.Raw, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem jx.Raw
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					s.Alerts = append(s.Alerts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alerts\"")
			}
		case "alertsSilenceURL":
			if err := func() error {
				s.AlertsSilenceURL.Reset()
				if err := s.AlertsSilenceURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alertsSilenceURL\"")
			}
		case "controllers":
			if err := func() error {
				s.Controllers.Reset()
				if err := s.Controllers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"controllers\"")
			}
		case "rebalanceStatus":
			if err := func() error {
				s.RebalanceStatus.Reset()
				if err := s.RebalanceStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rebalanceStatus\"")
			}
		case "rebalanceProgressUri":
			if err := func() error {
				s.RebalanceProgressUri.Reset()
				if err := s.RebalanceProgressUri.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rebalanceProgressUri\"")
			}
		case "stopRebalanceUri":
			if err := func() error {
				s.StopRebalanceUri.Reset()
				if err := s.StopRebalanceUri.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stopRebalanceUri\"")
			}
		case "nodeStatusesUri":
			if err := func() error {
				s.NodeStatusesUri.Reset()
				if err := s.NodeStatusesUri.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeStatusesUri\"")
			}
		case "nodeServicesUri":
			if err := func() error {
				s.NodeServicesUri.Reset()
				if err := s.NodeServicesUri.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeServicesUri\"")
			}
		case "maxBucketCount":
			if err := func() error {
				s.MaxBucketCount.Reset()
				if err := s.MaxBucketCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxBucketCount\"")
			}
		case "maxCollectionCount":
			if err := func() error {
				s.MaxCollectionCount.Reset()
				if err := s.MaxCollectionCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxCollectionCount\"")
			}
		case "maxScopeCount":
			if err := func() error {
				s.MaxScopeCount.Reset()
				if err := s.MaxScopeCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxScopeCount\"")
			}
		case "autoCompactionSettings":
			if err := func() error {
				s.AutoCompactionSettings.Reset()
				if err := s.AutoCompactionSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"autoCompactionSettings\"")
			}
		case "tasks":
			if err := func() error {
				s.Tasks.Reset()
				if err := s.Tasks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tasks\"")
			}
		case "counters":
			if err := func() error {
				s.Counters.Reset()
				if err := s.Counters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"counters\"")
			}
		case "indexStatusURI":
			if err := func() error {
				s.IndexStatusURI.Reset()
				if err := s.IndexStatusURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexStatusURI\"")
			}
		case "trustedCAsURI":
			if err := func() error {
				s.TrustedCAsURI.Reset()
				if err := s.TrustedCAsURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trustedCAsURI\"")
			}
		case "clusterName":
			if err := func() error {
				s.ClusterName.Reset()
				if err := s.ClusterName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterName\"")
			}
		case "clusterEncryptionLevel":
			if err := func() error {
				s.ClusterEncryptionLevel.Reset()
				if err := s.ClusterEncryptionLevel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterEncryptionLevel\"")
			}
		case "balanced":
			if err := func() error {
				s.Balanced.Reset()
				if err := s.Balanced.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balanced\"")
			}
		case "checkPermissionsURI":
			if err := func() error {
				s.CheckPermissionsURI.Reset()
				if err := s.CheckPermissionsURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"checkPermissionsURI\"")
			}
		case "memoryQuota":
			if err := func() error {
				s.MemoryQuota.Reset()
				if err := s.MemoryQuota.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memoryQuota\"")
			}
		case "indexMemoryQuota":
			if err := func() error {
				s.IndexMemoryQuota.Reset()
				if err := s.IndexMemoryQuota.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexMemoryQuota\"")
			}
		case "ftsMemoryQuota":
			if err := func() error {
				s.FtsMemoryQuota.Reset()
				if err := s.FtsMemoryQuota.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ftsMemoryQuota\"")
			}
		case "cbasMemoryQuota":
			if err := func() error {
				s.CbasMemoryQuota.Reset()
				if err := s.CbasMemoryQuota.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cbasMemoryQuota\"")
			}
		case "eventingMemoryQuota":
			if err := func() error {
				s.EventingMemoryQuota.Reset()
				if err := s.EventingMemoryQuota.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventingMemoryQuota\"")
			}
		case "storageTotals":
			if err := func() error {
				s.StorageTotals.Reset()
				if err := s.StorageTotals.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageTotals\"")
			}
		case "serverGroupsUri":
			if err := func() error {
				s.ServerGroupsUri.Reset()
				if err := s.ServerGroupsUri.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverGroupsUri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoAutoCompactionSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoAutoCompactionSettings) encodeFields(e *jx.Encoder) {
	{
		if s.ParallelDBAndViewCompaction.Set {
			e.FieldStart("parallelDBAndViewCompaction")
			s.ParallelDBAndViewCompaction.Encode(e)
		}
	}
	{
		if s.MagmaFragmentationPercentage.Set {
			e.FieldStart("magmaFragmentationPercentage")
			s.MagmaFragmentationPercentage.Encode(e)
		}
	}
	{
		if s.DatabaseFragmentationThreshold.Set {
			e.FieldStart("databaseFragmentationThreshold")
			s.DatabaseFragmentationThreshold.Encode(e)
		}
	}
	{
		if s.IndexCompactionMode.Set {
			e.FieldStart("indexCompactionMode")
			s.IndexCompactionMode.Encode(e)
		}
	}
	{
		if s.IndexCircularCompaction.Set {
			e.FieldStart("indexCircularCompaction")
			s.IndexCircularCompaction.Encode(e)
		}
	}
	{
		if s.IndexFragmentationThreshold.Set {
			e.FieldStart("indexFragmentationThreshold")
			s.IndexFragmentationThreshold.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoAutoCompactionSettings = [6]string{
	0: "parallelDBAndViewCompaction",
	1: "magmaFragmentationPercentage",
	2: "databaseFragmentationThreshold",
	3: "indexCompactionMode",
	4: "indexCircularCompaction",
	5: "indexFragmentationThreshold",
}

// Decode decodes PoolInfoAutoCompactionSettings from json.
func (s *PoolInfoAutoCompactionSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoAutoCompactionSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "parallelDBAndViewCompaction":
			if err := func() error {
				s.ParallelDBAndViewCompaction.Reset()
				if err := s.ParallelDBAndViewCompaction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parallelDBAndViewCompaction\"")
			}
		case "magmaFragmentationPercentage":
			if err := func() error {
				s.MagmaFragmentationPercentage.Reset()
				if err := s.MagmaFragmentationPercentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"magmaFragmentationPercentage\"")
			}
		case "databaseFragmentationThreshold":
			if err := func() error {
				s.DatabaseFragmentationThreshold.Reset()
				if err := s.DatabaseFragmentationThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"databaseFragmentationThreshold\"")
			}
		case "indexCompactionMode":
			if err := func() error {
				s.IndexCompactionMode.Reset()
				if err := s.IndexCompactionMode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexCompactionMode\"")
			}
		case "indexCircularCompaction":
			if err := func() error {
				s.IndexCircularCompaction.Reset()
				if err := s.IndexCircularCompaction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexCircularCompaction\"")
			}
		case "indexFragmentationThreshold":
			if err := func() error {
				s.IndexFragmentationThreshold.Reset()
				if err := s.IndexFragmentationThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexFragmentationThreshold\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoAutoCompactionSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoAutoCompactionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoAutoCompactionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold) encodeFields(e *jx.Encoder) {
	{
		if s.Percentage.Set {
			e.FieldStart("percentage")
			s.Percentage.Encode(e)
		}
	}
	{
		if s.Size.Set {
			e.FieldStart("size")
			s.Size.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold = [2]string{
	0: "percentage",
	1: "size",
}

// Decode decodes PoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold from json.
func (s *PoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "percentage":
			if err := func() error {
				s.Percentage.Reset()
				if err := s.Percentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"percentage\"")
			}
		case "size":
			if err := func() error {
				s.Size.Reset()
				if err := s.Size.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoAutoCompactionSettingsDatabaseFragmentationThreshold) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize as json.
func (s PoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize from json.
func (s *PoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize(v) {
	case PoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSizeUndefined:
		*s = PoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSizeUndefined
	default:
		*s = PoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoAutoCompactionSettingsDatabaseFragmentationThresholdSize) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoAutoCompactionSettingsIndexCircularCompaction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoAutoCompactionSettingsIndexCircularCompaction) encodeFields(e *jx.Encoder) {
	{
		if s.DaysOfWeek.Set {
			e.FieldStart("daysOfWeek")
			s.DaysOfWeek.Encode(e)
		}
	}
	{
		if s.Interval.Set {
			e.FieldStart("interval")
			s.Interval.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoAutoCompactionSettingsIndexCircularCompaction = [2]string{
	0: "daysOfWeek",
	1: "interval",
}

// Decode decodes PoolInfoAutoCompactionSettingsIndexCircularCompaction from json.
func (s *PoolInfoAutoCompactionSettingsIndexCircularCompaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoAutoCompactionSettingsIndexCircularCompaction to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "daysOfWeek":
			if err := func() error {
				s.DaysOfWeek.Reset()
				if err := s.DaysOfWeek.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysOfWeek\"")
			}
		case "interval":
			if err := func() error {
				s.Interval.Reset()
				if err := s.Interval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"interval\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoAutoCompactionSettingsIndexCircularCompaction")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoAutoCompactionSettingsIndexCircularCompaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoAutoCompactionSettingsIndexCircularCompaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoAutoCompactionSettingsIndexCircularCompactionInterval) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoAutoCompactionSettingsIndexCircularCompactionInterval) encodeFields(e *jx.Encoder) {
	{
		if s.FromHour.Set {
			e.FieldStart("fromHour")
			s.FromHour.Encode(e)
		}
	}
	{
		if s.ToHour.Set {
			e.FieldStart("toHour")
			s.ToHour.Encode(e)
		}
	}
	{
		if s.FromMinute.Set {
			e.FieldStart("fromMinute")
			s.FromMinute.Encode(e)
		}
	}
	{
		if s.ToMinute.Set {
			e.FieldStart("toMinute")
			s.ToMinute.Encode(e)
		}
	}
	{
		if s.AbortOutside.Set {
			e.FieldStart("abortOutside")
			s.AbortOutside.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoAutoCompactionSettingsIndexCircularCompactionInterval = [5]string{
	0: "fromHour",
	1: "toHour",
	2: "fromMinute",
	3: "toMinute",
	4: "abortOutside",
}

// Decode decodes PoolInfoAutoCompactionSettingsIndexCircularCompactionInterval from json.
func (s *PoolInfoAutoCompactionSettingsIndexCircularCompactionInterval) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoAutoCompactionSettingsIndexCircularCompactionInterval to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fromHour":
			if err := func() error {
				s.FromHour.Reset()
				if err := s.FromHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fromHour\"")
			}
		case "toHour":
			if err := func() error {
				s.ToHour.Reset()
				if err := s.ToHour.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"toHour\"")
			}
		case "fromMinute":
			if err := func() error {
				s.FromMinute.Reset()
				if err := s.FromMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fromMinute\"")
			}
		case "toMinute":
			if err := func() error {
				s.ToMinute.Reset()
				if err := s.ToMinute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"toMinute\"")
			}
		case "abortOutside":
			if err := func() error {
				s.AbortOutside.Reset()
				if err := s.AbortOutside.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"abortOutside\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoAutoCompactionSettingsIndexCircularCompactionInterval")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoAutoCompactionSettingsIndexCircularCompactionInterval) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoAutoCompactionSettingsIndexCircularCompactionInterval) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoAutoCompactionSettingsIndexCompactionMode as json.
func (s PoolInfoAutoCompactionSettingsIndexCompactionMode) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PoolInfoAutoCompactionSettingsIndexCompactionMode from json.
func (s *PoolInfoAutoCompactionSettingsIndexCompactionMode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoAutoCompactionSettingsIndexCompactionMode to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PoolInfoAutoCompactionSettingsIndexCompactionMode(v) {
	case PoolInfoAutoCompactionSettingsIndexCompactionModeCircular:
		*s = PoolInfoAutoCompactionSettingsIndexCompactionModeCircular
	default:
		*s = PoolInfoAutoCompactionSettingsIndexCompactionMode(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PoolInfoAutoCompactionSettingsIndexCompactionMode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoAutoCompactionSettingsIndexCompactionMode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoAutoCompactionSettingsIndexFragmentationThreshold) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoAutoCompactionSettingsIndexFragmentationThreshold) encodeFields(e *jx.Encoder) {
	{
		if s.Percentage.Set {
			e.FieldStart("percentage")
			s.Percentage.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoAutoCompactionSettingsIndexFragmentationThreshold = [1]string{
	0: "percentage",
}

// Decode decodes PoolInfoAutoCompactionSettingsIndexFragmentationThreshold from json.
func (s *PoolInfoAutoCompactionSettingsIndexFragmentationThreshold) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoAutoCompactionSettingsIndexFragmentationThreshold to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "percentage":
			if err := func() error {
				s.Percentage.Reset()
				if err := s.Percentage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"percentage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoAutoCompactionSettingsIndexFragmentationThreshold")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoAutoCompactionSettingsIndexFragmentationThreshold) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoAutoCompactionSettingsIndexFragmentationThreshold) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoBucketNamesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoBucketNamesItem) encodeFields(e *jx.Encoder) {
	{
		if s.BucketName.Set {
			e.FieldStart("bucketName")
			s.BucketName.Encode(e)
		}
	}
	{
		if s.UUID.Set {
			e.FieldStart("uuid")
			s.UUID.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoBucketNamesItem = [2]string{
	0: "bucketName",
	1: "uuid",
}

// Decode decodes PoolInfoBucketNamesItem from json.
func (s *PoolInfoBucketNamesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoBucketNamesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bucketName":
			if err := func() error {
				s.BucketName.Reset()
				if err := s.BucketName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bucketName\"")
			}
		case "uuid":
			if err := func() error {
				s.UUID.Reset()
				if err := s.UUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoBucketNamesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoBucketNamesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoBucketNamesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoBuckets) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoBuckets) encodeFields(e *jx.Encoder) {
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.TerseBucketsBase.Set {
			e.FieldStart("terseBucketsBase")
			s.TerseBucketsBase.Encode(e)
		}
	}
	{
		if s.TerseStreamingBucketsBase.Set {
			e.FieldStart("terseStreamingBucketsBase")
			s.TerseStreamingBucketsBase.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoBuckets = [3]string{
	0: "uri",
	1: "terseBucketsBase",
	2: "terseStreamingBucketsBase",
}

// Decode decodes PoolInfoBuckets from json.
func (s *PoolInfoBuckets) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoBuckets to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "terseBucketsBase":
			if err := func() error {
				s.TerseBucketsBase.Reset()
				if err := s.TerseBucketsBase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terseBucketsBase\"")
			}
		case "terseStreamingBucketsBase":
			if err := func() error {
				s.TerseStreamingBucketsBase.Reset()
				if err := s.TerseStreamingBucketsBase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"terseStreamingBucketsBase\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoBuckets")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoBuckets) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoBuckets) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoClusterEncryptionLevel as json.
func (s PoolInfoClusterEncryptionLevel) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PoolInfoClusterEncryptionLevel from json.
func (s *PoolInfoClusterEncryptionLevel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoClusterEncryptionLevel to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PoolInfoClusterEncryptionLevel(v) {
	case PoolInfoClusterEncryptionLevelNone:
		*s = PoolInfoClusterEncryptionLevelNone
	default:
		*s = PoolInfoClusterEncryptionLevel(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PoolInfoClusterEncryptionLevel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoClusterEncryptionLevel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoControllers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoControllers) encodeFields(e *jx.Encoder) {
	{
		if s.AddNode.Set {
			e.FieldStart("addNode")
			s.AddNode.Encode(e)
		}
	}
	{
		if s.Rebalance.Set {
			e.FieldStart("rebalance")
			s.Rebalance.Encode(e)
		}
	}
	{
		if s.FailOver.Set {
			e.FieldStart("failOver")
			s.FailOver.Encode(e)
		}
	}
	{
		if s.StartGracefulFailover.Set {
			e.FieldStart("startGracefulFailover")
			s.StartGracefulFailover.Encode(e)
		}
	}
	{
		if s.ReAddNode.Set {
			e.FieldStart("reAddNode")
			s.ReAddNode.Encode(e)
		}
	}
	{
		if s.ReFailOver.Set {
			e.FieldStart("reFailOver")
			s.ReFailOver.Encode(e)
		}
	}
	{
		if s.EjectNode.Set {
			e.FieldStart("ejectNode")
			s.EjectNode.Encode(e)
		}
	}
	{
		if s.SetRecoveryType.Set {
			e.FieldStart("setRecoveryType")
			s.SetRecoveryType.Encode(e)
		}
	}
	{
		if s.SetAutoCompaction.Set {
			e.FieldStart("setAutoCompaction")
			s.SetAutoCompaction.Encode(e)
		}
	}
	{
		if s.ClusterLogsCollection.Set {
			e.FieldStart("clusterLogsCollection")
			s.ClusterLogsCollection.Encode(e)
		}
	}
	{
		if s.Replication.Set {
			e.FieldStart("replication")
			s.Replication.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoControllers = [11]string{
	0:  "addNode",
	1:  "rebalance",
	2:  "failOver",
	3:  "startGracefulFailover",
	4:  "reAddNode",
	5:  "reFailOver",
	6:  "ejectNode",
	7:  "setRecoveryType",
	8:  "setAutoCompaction",
	9:  "clusterLogsCollection",
	10: "replication",
}

// Decode decodes PoolInfoControllers from json.
func (s *PoolInfoControllers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoControllers to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "addNode":
			if err := func() error {
				s.AddNode.Reset()
				if err := s.AddNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addNode\"")
			}
		case "rebalance":
			if err := func() error {
				s.Rebalance.Reset()
				if err := s.Rebalance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rebalance\"")
			}
		case "failOver":
			if err := func() error {
				s.FailOver.Reset()
				if err := s.FailOver.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"failOver\"")
			}
		case "startGracefulFailover":
			if err := func() error {
				s.StartGracefulFailover.Reset()
				if err := s.StartGracefulFailover.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startGracefulFailover\"")
			}
		case "reAddNode":
			if err := func() error {
				s.ReAddNode.Reset()
				if err := s.ReAddNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reAddNode\"")
			}
		case "reFailOver":
			if err := func() error {
				s.ReFailOver.Reset()
				if err := s.ReFailOver.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reFailOver\"")
			}
		case "ejectNode":
			if err := func() error {
				s.EjectNode.Reset()
				if err := s.EjectNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ejectNode\"")
			}
		case "setRecoveryType":
			if err := func() error {
				s.SetRecoveryType.Reset()
				if err := s.SetRecoveryType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"setRecoveryType\"")
			}
		case "setAutoCompaction":
			if err := func() error {
				s.SetAutoCompaction.Reset()
				if err := s.SetAutoCompaction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"setAutoCompaction\"")
			}
		case "clusterLogsCollection":
			if err := func() error {
				s.ClusterLogsCollection.Reset()
				if err := s.ClusterLogsCollection.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterLogsCollection\"")
			}
		case "replication":
			if err := func() error {
				s.Replication.Reset()
				if err := s.Replication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replication\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoControllers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoControllers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoControllers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoControllersAddNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoControllersAddNode) encodeFields(e *jx.Encoder) {
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoControllersAddNode = [1]string{
	0: "uri",
}

// Decode decodes PoolInfoControllersAddNode from json.
func (s *PoolInfoControllersAddNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoControllersAddNode to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoControllersAddNode")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoControllersAddNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoControllersAddNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoControllersClusterLogsCollection) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoControllersClusterLogsCollection) encodeFields(e *jx.Encoder) {
	{
		if s.StartURI.Set {
			e.FieldStart("startURI")
			s.StartURI.Encode(e)
		}
	}
	{
		if s.CancelURI.Set {
			e.FieldStart("cancelURI")
			s.CancelURI.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoControllersClusterLogsCollection = [2]string{
	0: "startURI",
	1: "cancelURI",
}

// Decode decodes PoolInfoControllersClusterLogsCollection from json.
func (s *PoolInfoControllersClusterLogsCollection) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoControllersClusterLogsCollection to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "startURI":
			if err := func() error {
				s.StartURI.Reset()
				if err := s.StartURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"startURI\"")
			}
		case "cancelURI":
			if err := func() error {
				s.CancelURI.Reset()
				if err := s.CancelURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cancelURI\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoControllersClusterLogsCollection")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoControllersClusterLogsCollection) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoControllersClusterLogsCollection) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoControllersEjectNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoControllersEjectNode) encodeFields(e *jx.Encoder) {
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoControllersEjectNode = [1]string{
	0: "uri",
}

// Decode decodes PoolInfoControllersEjectNode from json.
func (s *PoolInfoControllersEjectNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoControllersEjectNode to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoControllersEjectNode")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoControllersEjectNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoControllersEjectNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoControllersFailOver) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoControllersFailOver) encodeFields(e *jx.Encoder) {
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoControllersFailOver = [1]string{
	0: "uri",
}

// Decode decodes PoolInfoControllersFailOver from json.
func (s *PoolInfoControllersFailOver) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoControllersFailOver to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoControllersFailOver")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoControllersFailOver) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoControllersFailOver) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoControllersReAddNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoControllersReAddNode) encodeFields(e *jx.Encoder) {
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoControllersReAddNode = [1]string{
	0: "uri",
}

// Decode decodes PoolInfoControllersReAddNode from json.
func (s *PoolInfoControllersReAddNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoControllersReAddNode to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoControllersReAddNode")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoControllersReAddNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoControllersReAddNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoControllersReFailOver) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoControllersReFailOver) encodeFields(e *jx.Encoder) {
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoControllersReFailOver = [1]string{
	0: "uri",
}

// Decode decodes PoolInfoControllersReFailOver from json.
func (s *PoolInfoControllersReFailOver) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoControllersReFailOver to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoControllersReFailOver")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoControllersReFailOver) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoControllersReFailOver) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoControllersRebalance) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoControllersRebalance) encodeFields(e *jx.Encoder) {
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoControllersRebalance = [1]string{
	0: "uri",
}

// Decode decodes PoolInfoControllersRebalance from json.
func (s *PoolInfoControllersRebalance) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoControllersRebalance to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoControllersRebalance")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoControllersRebalance) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoControllersRebalance) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoControllersReplication) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoControllersReplication) encodeFields(e *jx.Encoder) {
	{
		if s.CreateURI.Set {
			e.FieldStart("createURI")
			s.CreateURI.Encode(e)
		}
	}
	{
		if s.ValidateURI.Set {
			e.FieldStart("validateURI")
			s.ValidateURI.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoControllersReplication = [2]string{
	0: "createURI",
	1: "validateURI",
}

// Decode decodes PoolInfoControllersReplication from json.
func (s *PoolInfoControllersReplication) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoControllersReplication to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "createURI":
			if err := func() error {
				s.CreateURI.Reset()
				if err := s.CreateURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createURI\"")
			}
		case "validateURI":
			if err := func() error {
				s.ValidateURI.Reset()
				if err := s.ValidateURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validateURI\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoControllersReplication")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoControllersReplication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoControllersReplication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoControllersSetAutoCompaction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoControllersSetAutoCompaction) encodeFields(e *jx.Encoder) {
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.ValidateURI.Set {
			e.FieldStart("validateURI")
			s.ValidateURI.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoControllersSetAutoCompaction = [2]string{
	0: "uri",
	1: "validateURI",
}

// Decode decodes PoolInfoControllersSetAutoCompaction from json.
func (s *PoolInfoControllersSetAutoCompaction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoControllersSetAutoCompaction to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "validateURI":
			if err := func() error {
				s.ValidateURI.Reset()
				if err := s.ValidateURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validateURI\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoControllersSetAutoCompaction")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoControllersSetAutoCompaction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoControllersSetAutoCompaction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoControllersSetRecoveryType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoControllersSetRecoveryType) encodeFields(e *jx.Encoder) {
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoControllersSetRecoveryType = [1]string{
	0: "uri",
}

// Decode decodes PoolInfoControllersSetRecoveryType from json.
func (s *PoolInfoControllersSetRecoveryType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoControllersSetRecoveryType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoControllersSetRecoveryType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoControllersSetRecoveryType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoControllersSetRecoveryType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoControllersStartGracefulFailover) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoControllersStartGracefulFailover) encodeFields(e *jx.Encoder) {
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoControllersStartGracefulFailover = [1]string{
	0: "uri",
}

// Decode decodes PoolInfoControllersStartGracefulFailover from json.
func (s *PoolInfoControllersStartGracefulFailover) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoControllersStartGracefulFailover to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoControllersStartGracefulFailover")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoControllersStartGracefulFailover) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoControllersStartGracefulFailover) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoCounters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoCounters) encodeFields(e *jx.Encoder) {
	{
		if s.RebalanceSuccess.Set {
			e.FieldStart("rebalance_success")
			s.RebalanceSuccess.Encode(e)
		}
	}
	{
		if s.RebalanceStart.Set {
			e.FieldStart("rebalance_start")
			s.RebalanceStart.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoCounters = [2]string{
	0: "rebalance_success",
	1: "rebalance_start",
}

// Decode decodes PoolInfoCounters from json.
func (s *PoolInfoCounters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoCounters to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rebalance_success":
			if err := func() error {
				s.RebalanceSuccess.Reset()
				if err := s.RebalanceSuccess.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rebalance_success\"")
			}
		case "rebalance_start":
			if err := func() error {
				s.RebalanceStart.Reset()
				if err := s.RebalanceStart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rebalance_start\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoCounters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoCounters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoCounters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PoolInfoRebalanceStatus as json.
func (s PoolInfoRebalanceStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PoolInfoRebalanceStatus from json.
func (s *PoolInfoRebalanceStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoRebalanceStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PoolInfoRebalanceStatus(v) {
	case PoolInfoRebalanceStatusNone:
		*s = PoolInfoRebalanceStatusNone
	default:
		*s = PoolInfoRebalanceStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PoolInfoRebalanceStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoRebalanceStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoRemoteClusters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoRemoteClusters) encodeFields(e *jx.Encoder) {
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.ValidateURI.Set {
			e.FieldStart("validateURI")
			s.ValidateURI.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoRemoteClusters = [2]string{
	0: "uri",
	1: "validateURI",
}

// Decode decodes PoolInfoRemoteClusters from json.
func (s *PoolInfoRemoteClusters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoRemoteClusters to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "validateURI":
			if err := func() error {
				s.ValidateURI.Reset()
				if err := s.ValidateURI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"validateURI\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoRemoteClusters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoRemoteClusters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoRemoteClusters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoStorageTotals) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoStorageTotals) encodeFields(e *jx.Encoder) {
	{
		if s.RAM.Set {
			e.FieldStart("ram")
			s.RAM.Encode(e)
		}
	}
	{
		if s.Hdd.Set {
			e.FieldStart("hdd")
			s.Hdd.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoStorageTotals = [2]string{
	0: "ram",
	1: "hdd",
}

// Decode decodes PoolInfoStorageTotals from json.
func (s *PoolInfoStorageTotals) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoStorageTotals to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ram":
			if err := func() error {
				s.RAM.Reset()
				if err := s.RAM.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ram\"")
			}
		case "hdd":
			if err := func() error {
				s.Hdd.Reset()
				if err := s.Hdd.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hdd\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoStorageTotals")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoStorageTotals) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoStorageTotals) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoStorageTotalsHdd) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoStorageTotalsHdd) encodeFields(e *jx.Encoder) {
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.QuotaTotal.Set {
			e.FieldStart("quotaTotal")
			s.QuotaTotal.Encode(e)
		}
	}
	{
		if s.Used.Set {
			e.FieldStart("used")
			s.Used.Encode(e)
		}
	}
	{
		if s.UsedByData.Set {
			e.FieldStart("usedByData")
			s.UsedByData.Encode(e)
		}
	}
	{
		if s.Free.Set {
			e.FieldStart("free")
			s.Free.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoStorageTotalsHdd = [5]string{
	0: "total",
	1: "quotaTotal",
	2: "used",
	3: "usedByData",
	4: "free",
}

// Decode decodes PoolInfoStorageTotalsHdd from json.
func (s *PoolInfoStorageTotalsHdd) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoStorageTotalsHdd to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "quotaTotal":
			if err := func() error {
				s.QuotaTotal.Reset()
				if err := s.QuotaTotal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quotaTotal\"")
			}
		case "used":
			if err := func() error {
				s.Used.Reset()
				if err := s.Used.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used\"")
			}
		case "usedByData":
			if err := func() error {
				s.UsedByData.Reset()
				if err := s.UsedByData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedByData\"")
			}
		case "free":
			if err := func() error {
				s.Free.Reset()
				if err := s.Free.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"free\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoStorageTotalsHdd")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoStorageTotalsHdd) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoStorageTotalsHdd) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoStorageTotalsRAM) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoStorageTotalsRAM) encodeFields(e *jx.Encoder) {
	{
		if s.Total.Set {
			e.FieldStart("total")
			s.Total.Encode(e)
		}
	}
	{
		if s.QuotaTotal.Set {
			e.FieldStart("quotaTotal")
			s.QuotaTotal.Encode(e)
		}
	}
	{
		if s.QuotaUsed.Set {
			e.FieldStart("quotaUsed")
			s.QuotaUsed.Encode(e)
		}
	}
	{
		if s.Used.Set {
			e.FieldStart("used")
			s.Used.Encode(e)
		}
	}
	{
		if s.UsedByData.Set {
			e.FieldStart("usedByData")
			s.UsedByData.Encode(e)
		}
	}
	{
		if s.QuotaUsedPerNode.Set {
			e.FieldStart("quotaUsedPerNode")
			s.QuotaUsedPerNode.Encode(e)
		}
	}
	{
		if s.QuotaTotalPerNode.Set {
			e.FieldStart("quotaTotalPerNode")
			s.QuotaTotalPerNode.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoStorageTotalsRAM = [7]string{
	0: "total",
	1: "quotaTotal",
	2: "quotaUsed",
	3: "used",
	4: "usedByData",
	5: "quotaUsedPerNode",
	6: "quotaTotalPerNode",
}

// Decode decodes PoolInfoStorageTotalsRAM from json.
func (s *PoolInfoStorageTotalsRAM) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoStorageTotalsRAM to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			if err := func() error {
				s.Total.Reset()
				if err := s.Total.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "quotaTotal":
			if err := func() error {
				s.QuotaTotal.Reset()
				if err := s.QuotaTotal.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quotaTotal\"")
			}
		case "quotaUsed":
			if err := func() error {
				s.QuotaUsed.Reset()
				if err := s.QuotaUsed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quotaUsed\"")
			}
		case "used":
			if err := func() error {
				s.Used.Reset()
				if err := s.Used.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used\"")
			}
		case "usedByData":
			if err := func() error {
				s.UsedByData.Reset()
				if err := s.UsedByData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedByData\"")
			}
		case "quotaUsedPerNode":
			if err := func() error {
				s.QuotaUsedPerNode.Reset()
				if err := s.QuotaUsedPerNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quotaUsedPerNode\"")
			}
		case "quotaTotalPerNode":
			if err := func() error {
				s.QuotaTotalPerNode.Reset()
				if err := s.QuotaTotalPerNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"quotaTotalPerNode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoStorageTotalsRAM")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoStorageTotalsRAM) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoStorageTotalsRAM) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolInfoTasks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolInfoTasks) encodeFields(e *jx.Encoder) {
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolInfoTasks = [1]string{
	0: "uri",
}

// Decode decodes PoolInfoTasks from json.
func (s *PoolInfoTasks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolInfoTasks to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolInfoTasks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolInfoTasks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolInfoTasks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolsInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolsInfo) encodeFields(e *jx.Encoder) {
	{
		if s.IsAdminCreds.Set {
			e.FieldStart("isAdminCreds")
			s.IsAdminCreds.Encode(e)
		}
	}
	{
		if s.IsROAdminCreds.Set {
			e.FieldStart("isROAdminCreds")
			s.IsROAdminCreds.Encode(e)
		}
	}
	{
		if s.AllowedServices != nil {
			e.FieldStart("allowedServices")
			e.ArrStart()
			for _, elem := range s.AllowedServices {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IsDeveloperPreview.Set {
			e.FieldStart("isDeveloperPreview")
			s.IsDeveloperPreview.Encode(e)
		}
	}
	{
		if s.PackageVariant.Set {
			e.FieldStart("packageVariant")
			s.PackageVariant.Encode(e)
		}
	}
	{
		if s.Pools != nil {
			e.FieldStart("pools")
			e.ArrStart()
			for _, elem := range s.Pools {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Settings.Set {
			e.FieldStart("settings")
			s.Settings.Encode(e)
		}
	}
	{
		if s.UUID.Set {
			e.FieldStart("uuid")
			s.UUID.Encode(e)
		}
	}
	{
		if s.ImplementationVersion.Set {
			e.FieldStart("implementationVersion")
			s.ImplementationVersion.Encode(e)
		}
	}
	{
		if s.ComponentsVersion.Set {
			e.FieldStart("componentsVersion")
			s.ComponentsVersion.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolsInfo = [10]string{
	0: "isAdminCreds",
	1: "isROAdminCreds",
	2: "allowedServices",
	3: "isDeveloperPreview",
	4: "packageVariant",
	5: "pools",
	6: "settings",
	7: "uuid",
	8: "implementationVersion",
	9: "componentsVersion",
}

// Decode decodes PoolsInfo from json.
func (s *PoolsInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolsInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isAdminCreds":
			if err := func() error {
				s.IsAdminCreds.Reset()
				if err := s.IsAdminCreds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isAdminCreds\"")
			}
		case "isROAdminCreds":
			if err := func() error {
				s.IsROAdminCreds.Reset()
				if err := s.IsROAdminCreds.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isROAdminCreds\"")
			}
		case "allowedServices":
			if err := func() error {
				s.AllowedServices = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedServices = append(s.AllowedServices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedServices\"")
			}
		case "isDeveloperPreview":
			if err := func() error {
				s.IsDeveloperPreview.Reset()
				if err := s.IsDeveloperPreview.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeveloperPreview\"")
			}
		case "packageVariant":
			if err := func() error {
				s.PackageVariant.Reset()
				if err := s.PackageVariant.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"packageVariant\"")
			}
		case "pools":
			if err := func() error {
				s.Pools = make([]PoolsInfoPoolsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PoolsInfoPoolsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Pools = append(s.Pools, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pools\"")
			}
		case "settings":
			if err := func() error {
				s.Settings.Reset()
				if err := s.Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"settings\"")
			}
		case "uuid":
			if err := func() error {
				s.UUID.Reset()
				if err := s.UUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "implementationVersion":
			if err := func() error {
				s.ImplementationVersion.Reset()
				if err := s.ImplementationVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implementationVersion\"")
			}
		case "componentsVersion":
			if err := func() error {
				s.ComponentsVersion.Reset()
				if err := s.ComponentsVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"componentsVersion\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolsInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolsInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolsInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s PoolsInfoComponentsVersion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s PoolsInfoComponentsVersion) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes PoolsInfoComponentsVersion from json.
func (s *PoolsInfoComponentsVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolsInfoComponentsVersion to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolsInfoComponentsVersion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PoolsInfoComponentsVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolsInfoComponentsVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolsInfoPoolsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolsInfoPoolsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.StreamingUri.Set {
			e.FieldStart("streamingUri")
			s.StreamingUri.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolsInfoPoolsItem = [3]string{
	0: "name",
	1: "uri",
	2: "streamingUri",
}

// Decode decodes PoolsInfoPoolsItem from json.
func (s *PoolsInfoPoolsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolsInfoPoolsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "streamingUri":
			if err := func() error {
				s.StreamingUri.Reset()
				if err := s.StreamingUri.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"streamingUri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolsInfoPoolsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolsInfoPoolsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolsInfoPoolsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PoolsInfoSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PoolsInfoSettings) encodeFields(e *jx.Encoder) {
	{
		if s.MaxParallelIndexers.Set {
			e.FieldStart("maxParallelIndexers")
			s.MaxParallelIndexers.Encode(e)
		}
	}
	{
		if s.ViewUpdateDaemon.Set {
			e.FieldStart("viewUpdateDaemon")
			s.ViewUpdateDaemon.Encode(e)
		}
	}
}

var jsonFieldsNameOfPoolsInfoSettings = [2]string{
	0: "maxParallelIndexers",
	1: "viewUpdateDaemon",
}

// Decode decodes PoolsInfoSettings from json.
func (s *PoolsInfoSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PoolsInfoSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "maxParallelIndexers":
			if err := func() error {
				s.MaxParallelIndexers.Reset()
				if err := s.MaxParallelIndexers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxParallelIndexers\"")
			}
		case "viewUpdateDaemon":
			if err := func() error {
				s.ViewUpdateDaemon.Reset()
				if err := s.ViewUpdateDaemon.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewUpdateDaemon\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PoolsInfoSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PoolsInfoSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PoolsInfoSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Service as json.
func (s Service) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes Service from json.
func (s *Service) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Service to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch Service(v) {
	case ServiceFts:
		*s = ServiceFts
	case ServiceIndex:
		*s = ServiceIndex
	case ServiceKv:
		*s = ServiceKv
	case ServiceN1ql:
		*s = ServiceN1ql
	default:
		*s = Service(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Service) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Service) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes StorageBackend as json.
func (s StorageBackend) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes StorageBackend from json.
func (s *StorageBackend) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode StorageBackend to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch StorageBackend(v) {
	case StorageBackendCouchstore:
		*s = StorageBackendCouchstore
	case StorageBackendMagma:
		*s = StorageBackendMagma
	default:
		*s = StorageBackend(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s StorageBackend) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *StorageBackend) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TerseBucketInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TerseBucketInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Rev.Set {
			e.FieldStart("rev")
			s.Rev.Encode(e)
		}
	}
	{
		if s.RevEpoch.Set {
			e.FieldStart("revEpoch")
			s.RevEpoch.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.NodeLocator.Set {
			e.FieldStart("nodeLocator")
			s.NodeLocator.Encode(e)
		}
	}
	{
		if s.BucketType.Set {
			e.FieldStart("bucketType")
			s.BucketType.Encode(e)
		}
	}
	{
		if s.StorageBackend.Set {
			e.FieldStart("storageBackend")
			s.StorageBackend.Encode(e)
		}
	}
	{
		if s.UUID.Set {
			e.FieldStart("uuid")
			s.UUID.Encode(e)
		}
	}
	{
		if s.URI.Set {
			e.FieldStart("uri")
			s.URI.Encode(e)
		}
	}
	{
		if s.StreamingUri.Set {
			e.FieldStart("streamingUri")
			s.StreamingUri.Encode(e)
		}
	}
	{
		if s.BucketCapabilitiesVer.Set {
			e.FieldStart("bucketCapabilitiesVer")
			s.BucketCapabilitiesVer.Encode(e)
		}
	}
	{
		if s.BucketCapabilities != nil {
			e.FieldStart("bucketCapabilities")
			e.ArrStart()
			for _, elem := range s.BucketCapabilities {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CollectionManifestUid.Set {
			e.FieldStart("collectionManifestUid")
			s.CollectionManifestUid.Encode(e)
		}
	}
	{
		if s.Ddocs.Set {
			e.FieldStart("ddocs")
			s.Ddocs.Encode(e)
		}
	}
	{
		if s.VBucketServerMap.Set {
			e.FieldStart("vBucketServerMap")
			s.VBucketServerMap.Encode(e)
		}
	}
	{
		if s.Nodes != nil {
			e.FieldStart("nodes")
			e.ArrStart()
			for _, elem := range s.Nodes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.NodesExt != nil {
			e.FieldStart("nodesExt")
			e.ArrStart()
			for _, elem := range s.NodesExt {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ClusterCapabilitiesVer != nil {
			e.FieldStart("clusterCapabilitiesVer")
			s.ClusterCapabilitiesVer.Encode(e)
		}
	}
	{
		if s.ClusterCapabilities.Set {
			e.FieldStart("clusterCapabilities")
			s.ClusterCapabilities.Encode(e)
		}
	}
}

var jsonFieldsNameOfTerseBucketInfo = [18]string{
	0:  "rev",
	1:  "revEpoch",
	2:  "name",
	3:  "nodeLocator",
	4:  "bucketType",
	5:  "storageBackend",
	6:  "uuid",
	7:  "uri",
	8:  "streamingUri",
	9:  "bucketCapabilitiesVer",
	10: "bucketCapabilities",
	11: "collectionManifestUid",
	12: "ddocs",
	13: "vBucketServerMap",
	14: "nodes",
	15: "nodesExt",
	16: "clusterCapabilitiesVer",
	17: "clusterCapabilities",
}

// Decode decodes TerseBucketInfo from json.
func (s *TerseBucketInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TerseBucketInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rev":
			if err := func() error {
				s.Rev.Reset()
				if err := s.Rev.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rev\"")
			}
		case "revEpoch":
			if err := func() error {
				s.RevEpoch.Reset()
				if err := s.RevEpoch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revEpoch\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "nodeLocator":
			if err := func() error {
				s.NodeLocator.Reset()
				if err := s.NodeLocator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeLocator\"")
			}
		case "bucketType":
			if err := func() error {
				s.BucketType.Reset()
				if err := s.BucketType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bucketType\"")
			}
		case "storageBackend":
			if err := func() error {
				s.StorageBackend.Reset()
				if err := s.StorageBackend.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"storageBackend\"")
			}
		case "uuid":
			if err := func() error {
				s.UUID.Reset()
				if err := s.UUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "uri":
			if err := func() error {
				s.URI.Reset()
				if err := s.URI.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		case "streamingUri":
			if err := func() error {
				s.StreamingUri.Reset()
				if err := s.StreamingUri.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"streamingUri\"")
			}
		case "bucketCapabilitiesVer":
			if err := func() error {
				s.BucketCapabilitiesVer.Reset()
				if err := s.BucketCapabilitiesVer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bucketCapabilitiesVer\"")
			}
		case "bucketCapabilities":
			if err := func() error {
				s.BucketCapabilities = make([]BucketCapability, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BucketCapability
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BucketCapabilities = append(s.BucketCapabilities, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bucketCapabilities\"")
			}
		case "collectionManifestUid":
			if err := func() error {
				s.CollectionManifestUid.Reset()
				if err := s.CollectionManifestUid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"collectionManifestUid\"")
			}
		case "ddocs":
			if err := func() error {
				s.Ddocs.Reset()
				if err := s.Ddocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ddocs\"")
			}
		case "vBucketServerMap":
			if err := func() error {
				s.VBucketServerMap.Reset()
				if err := s.VBucketServerMap.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vBucketServerMap\"")
			}
		case "nodes":
			if err := func() error {
				s.Nodes = make([]TerseNodeInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TerseNodeInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "nodesExt":
			if err := func() error {
				s.NodesExt = make([]TerseNodeExtInfo, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem TerseNodeExtInfo
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.NodesExt = append(s.NodesExt, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodesExt\"")
			}
		case "clusterCapabilitiesVer":
			if err := func() error {
				if err := s.ClusterCapabilitiesVer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterCapabilitiesVer\"")
			}
		case "clusterCapabilities":
			if err := func() error {
				s.ClusterCapabilities.Reset()
				if err := s.ClusterCapabilities.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clusterCapabilities\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TerseBucketInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TerseBucketInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TerseBucketInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TerseBucketInfoDdocs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TerseBucketInfoDdocs) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uri")
		e.Str(s.URI)
	}
}

var jsonFieldsNameOfTerseBucketInfoDdocs = [1]string{
	0: "uri",
}

// Decode decodes TerseBucketInfoDdocs from json.
func (s *TerseBucketInfoDdocs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TerseBucketInfoDdocs to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uri":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URI = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uri\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TerseBucketInfoDdocs")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTerseBucketInfoDdocs) {
					name = jsonFieldsNameOfTerseBucketInfoDdocs[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TerseBucketInfoDdocs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TerseBucketInfoDdocs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TerseNodeExtInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TerseNodeExtInfo) encodeFields(e *jx.Encoder) {
	{
		if s.Services.Set {
			e.FieldStart("services")
			s.Services.Encode(e)
		}
	}
	{
		if s.ThisNode.Set {
			e.FieldStart("thisNode")
			s.ThisNode.Encode(e)
		}
	}
	{
		if s.Hostname.Set {
			e.FieldStart("hostname")
			s.Hostname.Encode(e)
		}
	}
}

var jsonFieldsNameOfTerseNodeExtInfo = [3]string{
	0: "services",
	1: "thisNode",
	2: "hostname",
}

// Decode decodes TerseNodeExtInfo from json.
func (s *TerseNodeExtInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TerseNodeExtInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "services":
			if err := func() error {
				s.Services.Reset()
				if err := s.Services.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"services\"")
			}
		case "thisNode":
			if err := func() error {
				s.ThisNode.Reset()
				if err := s.ThisNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thisNode\"")
			}
		case "hostname":
			if err := func() error {
				s.Hostname.Reset()
				if err := s.Hostname.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostname\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TerseNodeExtInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TerseNodeExtInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TerseNodeExtInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TerseNodeExtInfoServices) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TerseNodeExtInfoServices) encodeFields(e *jx.Encoder) {
	{
		if s.Capi.Set {
			e.FieldStart("capi")
			s.Capi.Encode(e)
		}
	}
	{
		if s.CapiSSL.Set {
			e.FieldStart("capiSSL")
			s.CapiSSL.Encode(e)
		}
	}
	{
		if s.Fts.Set {
			e.FieldStart("fts")
			s.Fts.Encode(e)
		}
	}
	{
		if s.FtsGRPC.Set {
			e.FieldStart("ftsGRPC")
			s.FtsGRPC.Encode(e)
		}
	}
	{
		if s.FtsGRPCSSL.Set {
			e.FieldStart("ftsGRPCSSL")
			s.FtsGRPCSSL.Encode(e)
		}
	}
	{
		if s.FtsSSL.Set {
			e.FieldStart("ftsSSL")
			s.FtsSSL.Encode(e)
		}
	}
	{
		if s.IndexAdmin.Set {
			e.FieldStart("indexAdmin")
			s.IndexAdmin.Encode(e)
		}
	}
	{
		if s.IndexHttp.Set {
			e.FieldStart("indexHttp")
			s.IndexHttp.Encode(e)
		}
	}
	{
		if s.IndexHttps.Set {
			e.FieldStart("indexHttps")
			s.IndexHttps.Encode(e)
		}
	}
	{
		if s.IndexScan.Set {
			e.FieldStart("indexScan")
			s.IndexScan.Encode(e)
		}
	}
	{
		if s.IndexStreamCatchup.Set {
			e.FieldStart("indexStreamCatchup")
			s.IndexStreamCatchup.Encode(e)
		}
	}
	{
		if s.IndexStreamInit.Set {
			e.FieldStart("indexStreamInit")
			s.IndexStreamInit.Encode(e)
		}
	}
	{
		if s.IndexStreamMaint.Set {
			e.FieldStart("indexStreamMaint")
			s.IndexStreamMaint.Encode(e)
		}
	}
	{
		if s.Kv.Set {
			e.FieldStart("kv")
			s.Kv.Encode(e)
		}
	}
	{
		if s.KvSSL.Set {
			e.FieldStart("kvSSL")
			s.KvSSL.Encode(e)
		}
	}
	{
		if s.Mgmt.Set {
			e.FieldStart("mgmt")
			s.Mgmt.Encode(e)
		}
	}
	{
		if s.MgmtSSL.Set {
			e.FieldStart("mgmtSSL")
			s.MgmtSSL.Encode(e)
		}
	}
	{
		if s.N1ql.Set {
			e.FieldStart("n1ql")
			s.N1ql.Encode(e)
		}
	}
	{
		if s.N1qlSSL.Set {
			e.FieldStart("n1qlSSL")
			s.N1qlSSL.Encode(e)
		}
	}
	{
		if s.Projector.Set {
			e.FieldStart("projector")
			s.Projector.Encode(e)
		}
	}
}

var jsonFieldsNameOfTerseNodeExtInfoServices = [20]string{
	0:  "capi",
	1:  "capiSSL",
	2:  "fts",
	3:  "ftsGRPC",
	4:  "ftsGRPCSSL",
	5:  "ftsSSL",
	6:  "indexAdmin",
	7:  "indexHttp",
	8:  "indexHttps",
	9:  "indexScan",
	10: "indexStreamCatchup",
	11: "indexStreamInit",
	12: "indexStreamMaint",
	13: "kv",
	14: "kvSSL",
	15: "mgmt",
	16: "mgmtSSL",
	17: "n1ql",
	18: "n1qlSSL",
	19: "projector",
}

// Decode decodes TerseNodeExtInfoServices from json.
func (s *TerseNodeExtInfoServices) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TerseNodeExtInfoServices to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "capi":
			if err := func() error {
				s.Capi.Reset()
				if err := s.Capi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capi\"")
			}
		case "capiSSL":
			if err := func() error {
				s.CapiSSL.Reset()
				if err := s.CapiSSL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"capiSSL\"")
			}
		case "fts":
			if err := func() error {
				s.Fts.Reset()
				if err := s.Fts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fts\"")
			}
		case "ftsGRPC":
			if err := func() error {
				s.FtsGRPC.Reset()
				if err := s.FtsGRPC.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ftsGRPC\"")
			}
		case "ftsGRPCSSL":
			if err := func() error {
				s.FtsGRPCSSL.Reset()
				if err := s.FtsGRPCSSL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ftsGRPCSSL\"")
			}
		case "ftsSSL":
			if err := func() error {
				s.FtsSSL.Reset()
				if err := s.FtsSSL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ftsSSL\"")
			}
		case "indexAdmin":
			if err := func() error {
				s.IndexAdmin.Reset()
				if err := s.IndexAdmin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexAdmin\"")
			}
		case "indexHttp":
			if err := func() error {
				s.IndexHttp.Reset()
				if err := s.IndexHttp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexHttp\"")
			}
		case "indexHttps":
			if err := func() error {
				s.IndexHttps.Reset()
				if err := s.IndexHttps.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexHttps\"")
			}
		case "indexScan":
			if err := func() error {
				s.IndexScan.Reset()
				if err := s.IndexScan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexScan\"")
			}
		case "indexStreamCatchup":
			if err := func() error {
				s.IndexStreamCatchup.Reset()
				if err := s.IndexStreamCatchup.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexStreamCatchup\"")
			}
		case "indexStreamInit":
			if err := func() error {
				s.IndexStreamInit.Reset()
				if err := s.IndexStreamInit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexStreamInit\"")
			}
		case "indexStreamMaint":
			if err := func() error {
				s.IndexStreamMaint.Reset()
				if err := s.IndexStreamMaint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"indexStreamMaint\"")
			}
		case "kv":
			if err := func() error {
				s.Kv.Reset()
				if err := s.Kv.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kv\"")
			}
		case "kvSSL":
			if err := func() error {
				s.KvSSL.Reset()
				if err := s.KvSSL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"kvSSL\"")
			}
		case "mgmt":
			if err := func() error {
				s.Mgmt.Reset()
				if err := s.Mgmt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mgmt\"")
			}
		case "mgmtSSL":
			if err := func() error {
				s.MgmtSSL.Reset()
				if err := s.MgmtSSL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mgmtSSL\"")
			}
		case "n1ql":
			if err := func() error {
				s.N1ql.Reset()
				if err := s.N1ql.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"n1ql\"")
			}
		case "n1qlSSL":
			if err := func() error {
				s.N1qlSSL.Reset()
				if err := s.N1qlSSL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"n1qlSSL\"")
			}
		case "projector":
			if err := func() error {
				s.Projector.Reset()
				if err := s.Projector.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projector\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TerseNodeExtInfoServices")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TerseNodeExtInfoServices) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TerseNodeExtInfoServices) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TerseNodeInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TerseNodeInfo) encodeFields(e *jx.Encoder) {
	{
		if s.CouchApiBase.Set {
			e.FieldStart("couchApiBase")
			s.CouchApiBase.Encode(e)
		}
	}
	{
		if s.Hostanme.Set {
			e.FieldStart("hostanme")
			s.Hostanme.Encode(e)
		}
	}
	{
		if s.Ports.Set {
			e.FieldStart("ports")
			s.Ports.Encode(e)
		}
	}
}

var jsonFieldsNameOfTerseNodeInfo = [3]string{
	0: "couchApiBase",
	1: "hostanme",
	2: "ports",
}

// Decode decodes TerseNodeInfo from json.
func (s *TerseNodeInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TerseNodeInfo to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "couchApiBase":
			if err := func() error {
				s.CouchApiBase.Reset()
				if err := s.CouchApiBase.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"couchApiBase\"")
			}
		case "hostanme":
			if err := func() error {
				s.Hostanme.Reset()
				if err := s.Hostanme.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hostanme\"")
			}
		case "ports":
			if err := func() error {
				s.Ports.Reset()
				if err := s.Ports.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ports\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TerseNodeInfo")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TerseNodeInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TerseNodeInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TerseNodeInfoPorts) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TerseNodeInfoPorts) encodeFields(e *jx.Encoder) {
	{
		if s.Direct.Set {
			e.FieldStart("direct")
			s.Direct.Encode(e)
		}
	}
}

var jsonFieldsNameOfTerseNodeInfoPorts = [1]string{
	0: "direct",
}

// Decode decodes TerseNodeInfoPorts from json.
func (s *TerseNodeInfoPorts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TerseNodeInfoPorts to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "direct":
			if err := func() error {
				s.Direct.Reset()
				if err := s.Direct.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"direct\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TerseNodeInfoPorts")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TerseNodeInfoPorts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TerseNodeInfoPorts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VBucketServerMap) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VBucketServerMap) encodeFields(e *jx.Encoder) {
	{
		if s.HashAlgorithm.Set {
			e.FieldStart("hashAlgorithm")
			s.HashAlgorithm.Encode(e)
		}
	}
	{
		if s.NumReplicas.Set {
			e.FieldStart("numReplicas")
			s.NumReplicas.Encode(e)
		}
	}
	{
		if s.ServerList != nil {
			e.FieldStart("serverList")
			e.ArrStart()
			for _, elem := range s.ServerList {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VBucketMap != nil {
			e.FieldStart("vBucketMap")
			e.ArrStart()
			for _, elem := range s.VBucketMap {
				e.ArrStart()
				for _, elem := range elem {
					e.Int(elem)
				}
				e.ArrEnd()
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfVBucketServerMap = [4]string{
	0: "hashAlgorithm",
	1: "numReplicas",
	2: "serverList",
	3: "vBucketMap",
}

// Decode decodes VBucketServerMap from json.
func (s *VBucketServerMap) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VBucketServerMap to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hashAlgorithm":
			if err := func() error {
				s.HashAlgorithm.Reset()
				if err := s.HashAlgorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hashAlgorithm\"")
			}
		case "numReplicas":
			if err := func() error {
				s.NumReplicas.Reset()
				if err := s.NumReplicas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"numReplicas\"")
			}
		case "serverList":
			if err := func() error {
				s.ServerList = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ServerList = append(s.ServerList, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverList\"")
			}
		case "vBucketMap":
			if err := func() error {
				s.VBucketMap = make([][]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem []int
					elem = make([]int, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elemElem int
						v, err := d.Int()
						elemElem = int(v)
						if err != nil {
							return err
						}
						elem = append(elem, elemElem)
						return nil
					}); err != nil {
						return err
					}
					s.VBucketMap = append(s.VBucketMap, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vBucketMap\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VBucketServerMap")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VBucketServerMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VBucketServerMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
