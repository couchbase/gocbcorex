// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package gocbcorex

import (
	"context"
	"github.com/couchbase/gocbcorex/memdx"
	"sync"
)

// Ensure, that KvClientMock does implement KvClient.
// If this is not the case, regenerate this file with moq.
var _ KvClient = &KvClientMock{}

// KvClientMock is a mock implementation of KvClient.
//
//	func TestSomethingThatUsesKvClient(t *testing.T) {
//
//		// make and configure a mocked KvClient
//		mockedKvClient := &KvClientMock{
//			AddFunc: func(ctx context.Context, req *memdx.AddRequest) (*memdx.AddResponse, error) {
//				panic("mock out the Add method")
//			},
//			AppendFunc: func(ctx context.Context, req *memdx.AppendRequest) (*memdx.AppendResponse, error) {
//				panic("mock out the Append method")
//			},
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			DecrementFunc: func(ctx context.Context, req *memdx.DecrementRequest) (*memdx.DecrementResponse, error) {
//				panic("mock out the Decrement method")
//			},
//			DeleteFunc: func(ctx context.Context, req *memdx.DeleteRequest) (*memdx.DeleteResponse, error) {
//				panic("mock out the Delete method")
//			},
//			DeleteMetaFunc: func(ctx context.Context, req *memdx.DeleteMetaRequest) (*memdx.DeleteMetaResponse, error) {
//				panic("mock out the DeleteMeta method")
//			},
//			GetFunc: func(ctx context.Context, req *memdx.GetRequest) (*memdx.GetResponse, error) {
//				panic("mock out the Get method")
//			},
//			GetAndLockFunc: func(ctx context.Context, req *memdx.GetAndLockRequest) (*memdx.GetAndLockResponse, error) {
//				panic("mock out the GetAndLock method")
//			},
//			GetAndTouchFunc: func(ctx context.Context, req *memdx.GetAndTouchRequest) (*memdx.GetAndTouchResponse, error) {
//				panic("mock out the GetAndTouch method")
//			},
//			GetClusterConfigFunc: func(ctx context.Context, req *memdx.GetClusterConfigRequest) ([]byte, error) {
//				panic("mock out the GetClusterConfig method")
//			},
//			GetCollectionIDFunc: func(ctx context.Context, req *memdx.GetCollectionIDRequest) (*memdx.GetCollectionIDResponse, error) {
//				panic("mock out the GetCollectionID method")
//			},
//			GetMetaFunc: func(ctx context.Context, req *memdx.GetMetaRequest) (*memdx.GetMetaResponse, error) {
//				panic("mock out the GetMeta method")
//			},
//			GetRandomFunc: func(ctx context.Context, req *memdx.GetRandomRequest) (*memdx.GetRandomResponse, error) {
//				panic("mock out the GetRandom method")
//			},
//			GetReplicaFunc: func(ctx context.Context, req *memdx.GetReplicaRequest) (*memdx.GetReplicaResponse, error) {
//				panic("mock out the GetReplica method")
//			},
//			HasFeatureFunc: func(feat memdx.HelloFeature) bool {
//				panic("mock out the HasFeature method")
//			},
//			IncrementFunc: func(ctx context.Context, req *memdx.IncrementRequest) (*memdx.IncrementResponse, error) {
//				panic("mock out the Increment method")
//			},
//			LoadFactorFunc: func() float64 {
//				panic("mock out the LoadFactor method")
//			},
//			LookupInFunc: func(ctx context.Context, req *memdx.LookupInRequest) (*memdx.LookupInResponse, error) {
//				panic("mock out the LookupIn method")
//			},
//			MutateInFunc: func(ctx context.Context, req *memdx.MutateInRequest) (*memdx.MutateInResponse, error) {
//				panic("mock out the MutateIn method")
//			},
//			PrependFunc: func(ctx context.Context, req *memdx.PrependRequest) (*memdx.PrependResponse, error) {
//				panic("mock out the Prepend method")
//			},
//			ReconfigureFunc: func(config *KvClientConfig, cb func(error)) error {
//				panic("mock out the Reconfigure method")
//			},
//			RemoteAddressFunc: func() string {
//				panic("mock out the RemoteAddress method")
//			},
//			ReplaceFunc: func(ctx context.Context, req *memdx.ReplaceRequest) (*memdx.ReplaceResponse, error) {
//				panic("mock out the Replace method")
//			},
//			SetFunc: func(ctx context.Context, req *memdx.SetRequest) (*memdx.SetResponse, error) {
//				panic("mock out the Set method")
//			},
//			SetMetaFunc: func(ctx context.Context, req *memdx.SetMetaRequest) (*memdx.SetMetaResponse, error) {
//				panic("mock out the SetMeta method")
//			},
//			TouchFunc: func(ctx context.Context, req *memdx.TouchRequest) (*memdx.TouchResponse, error) {
//				panic("mock out the Touch method")
//			},
//			UnlockFunc: func(ctx context.Context, req *memdx.UnlockRequest) (*memdx.UnlockResponse, error) {
//				panic("mock out the Unlock method")
//			},
//		}
//
//		// use mockedKvClient in code that requires KvClient
//		// and then make assertions.
//
//	}
type KvClientMock struct {
	// AddFunc mocks the Add method.
	AddFunc func(ctx context.Context, req *memdx.AddRequest) (*memdx.AddResponse, error)

	// AppendFunc mocks the Append method.
	AppendFunc func(ctx context.Context, req *memdx.AppendRequest) (*memdx.AppendResponse, error)

	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// DecrementFunc mocks the Decrement method.
	DecrementFunc func(ctx context.Context, req *memdx.DecrementRequest) (*memdx.DecrementResponse, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, req *memdx.DeleteRequest) (*memdx.DeleteResponse, error)

	// DeleteMetaFunc mocks the DeleteMeta method.
	DeleteMetaFunc func(ctx context.Context, req *memdx.DeleteMetaRequest) (*memdx.DeleteMetaResponse, error)

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, req *memdx.GetRequest) (*memdx.GetResponse, error)

	// GetAndLockFunc mocks the GetAndLock method.
	GetAndLockFunc func(ctx context.Context, req *memdx.GetAndLockRequest) (*memdx.GetAndLockResponse, error)

	// GetAndTouchFunc mocks the GetAndTouch method.
	GetAndTouchFunc func(ctx context.Context, req *memdx.GetAndTouchRequest) (*memdx.GetAndTouchResponse, error)

	// GetClusterConfigFunc mocks the GetClusterConfig method.
	GetClusterConfigFunc func(ctx context.Context, req *memdx.GetClusterConfigRequest) ([]byte, error)

	// GetCollectionIDFunc mocks the GetCollectionID method.
	GetCollectionIDFunc func(ctx context.Context, req *memdx.GetCollectionIDRequest) (*memdx.GetCollectionIDResponse, error)

	// GetMetaFunc mocks the GetMeta method.
	GetMetaFunc func(ctx context.Context, req *memdx.GetMetaRequest) (*memdx.GetMetaResponse, error)

	// GetRandomFunc mocks the GetRandom method.
	GetRandomFunc func(ctx context.Context, req *memdx.GetRandomRequest) (*memdx.GetRandomResponse, error)

	// GetReplicaFunc mocks the GetReplica method.
	GetReplicaFunc func(ctx context.Context, req *memdx.GetReplicaRequest) (*memdx.GetReplicaResponse, error)

	// HasFeatureFunc mocks the HasFeature method.
	HasFeatureFunc func(feat memdx.HelloFeature) bool

	// IncrementFunc mocks the Increment method.
	IncrementFunc func(ctx context.Context, req *memdx.IncrementRequest) (*memdx.IncrementResponse, error)

	// LoadFactorFunc mocks the LoadFactor method.
	LoadFactorFunc func() float64

	// LookupInFunc mocks the LookupIn method.
	LookupInFunc func(ctx context.Context, req *memdx.LookupInRequest) (*memdx.LookupInResponse, error)

	// MutateInFunc mocks the MutateIn method.
	MutateInFunc func(ctx context.Context, req *memdx.MutateInRequest) (*memdx.MutateInResponse, error)

	// PrependFunc mocks the Prepend method.
	PrependFunc func(ctx context.Context, req *memdx.PrependRequest) (*memdx.PrependResponse, error)

	// ReconfigureFunc mocks the Reconfigure method.
	ReconfigureFunc func(config *KvClientConfig, cb func(error)) error

	// RemoteAddressFunc mocks the RemoteAddress method.
	RemoteAddressFunc func() string

	// ReplaceFunc mocks the Replace method.
	ReplaceFunc func(ctx context.Context, req *memdx.ReplaceRequest) (*memdx.ReplaceResponse, error)

	// SetFunc mocks the Set method.
	SetFunc func(ctx context.Context, req *memdx.SetRequest) (*memdx.SetResponse, error)

	// SetMetaFunc mocks the SetMeta method.
	SetMetaFunc func(ctx context.Context, req *memdx.SetMetaRequest) (*memdx.SetMetaResponse, error)

	// TouchFunc mocks the Touch method.
	TouchFunc func(ctx context.Context, req *memdx.TouchRequest) (*memdx.TouchResponse, error)

	// UnlockFunc mocks the Unlock method.
	UnlockFunc func(ctx context.Context, req *memdx.UnlockRequest) (*memdx.UnlockResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// Add holds details about calls to the Add method.
		Add []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.AddRequest
		}
		// Append holds details about calls to the Append method.
		Append []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.AppendRequest
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Decrement holds details about calls to the Decrement method.
		Decrement []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.DecrementRequest
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.DeleteRequest
		}
		// DeleteMeta holds details about calls to the DeleteMeta method.
		DeleteMeta []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.DeleteMetaRequest
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetRequest
		}
		// GetAndLock holds details about calls to the GetAndLock method.
		GetAndLock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetAndLockRequest
		}
		// GetAndTouch holds details about calls to the GetAndTouch method.
		GetAndTouch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetAndTouchRequest
		}
		// GetClusterConfig holds details about calls to the GetClusterConfig method.
		GetClusterConfig []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetClusterConfigRequest
		}
		// GetCollectionID holds details about calls to the GetCollectionID method.
		GetCollectionID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetCollectionIDRequest
		}
		// GetMeta holds details about calls to the GetMeta method.
		GetMeta []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetMetaRequest
		}
		// GetRandom holds details about calls to the GetRandom method.
		GetRandom []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetRandomRequest
		}
		// GetReplica holds details about calls to the GetReplica method.
		GetReplica []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetReplicaRequest
		}
		// HasFeature holds details about calls to the HasFeature method.
		HasFeature []struct {
			// Feat is the feat argument value.
			Feat memdx.HelloFeature
		}
		// Increment holds details about calls to the Increment method.
		Increment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.IncrementRequest
		}
		// LoadFactor holds details about calls to the LoadFactor method.
		LoadFactor []struct {
		}
		// LookupIn holds details about calls to the LookupIn method.
		LookupIn []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.LookupInRequest
		}
		// MutateIn holds details about calls to the MutateIn method.
		MutateIn []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.MutateInRequest
		}
		// Prepend holds details about calls to the Prepend method.
		Prepend []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.PrependRequest
		}
		// Reconfigure holds details about calls to the Reconfigure method.
		Reconfigure []struct {
			// Config is the config argument value.
			Config *KvClientConfig
			// Cb is the cb argument value.
			Cb func(error)
		}
		// RemoteAddress holds details about calls to the RemoteAddress method.
		RemoteAddress []struct {
		}
		// Replace holds details about calls to the Replace method.
		Replace []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.ReplaceRequest
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.SetRequest
		}
		// SetMeta holds details about calls to the SetMeta method.
		SetMeta []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.SetMetaRequest
		}
		// Touch holds details about calls to the Touch method.
		Touch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.TouchRequest
		}
		// Unlock holds details about calls to the Unlock method.
		Unlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.UnlockRequest
		}
	}
	lockAdd              sync.RWMutex
	lockAppend           sync.RWMutex
	lockClose            sync.RWMutex
	lockDecrement        sync.RWMutex
	lockDelete           sync.RWMutex
	lockDeleteMeta       sync.RWMutex
	lockGet              sync.RWMutex
	lockGetAndLock       sync.RWMutex
	lockGetAndTouch      sync.RWMutex
	lockGetClusterConfig sync.RWMutex
	lockGetCollectionID  sync.RWMutex
	lockGetMeta          sync.RWMutex
	lockGetRandom        sync.RWMutex
	lockGetReplica       sync.RWMutex
	lockHasFeature       sync.RWMutex
	lockIncrement        sync.RWMutex
	lockLoadFactor       sync.RWMutex
	lockLookupIn         sync.RWMutex
	lockMutateIn         sync.RWMutex
	lockPrepend          sync.RWMutex
	lockReconfigure      sync.RWMutex
	lockRemoteAddress    sync.RWMutex
	lockReplace          sync.RWMutex
	lockSet              sync.RWMutex
	lockSetMeta          sync.RWMutex
	lockTouch            sync.RWMutex
	lockUnlock           sync.RWMutex
}

// Add calls AddFunc.
func (mock *KvClientMock) Add(ctx context.Context, req *memdx.AddRequest) (*memdx.AddResponse, error) {
	if mock.AddFunc == nil {
		panic("KvClientMock.AddFunc: method is nil but KvClient.Add was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.AddRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockAdd.Lock()
	mock.calls.Add = append(mock.calls.Add, callInfo)
	mock.lockAdd.Unlock()
	return mock.AddFunc(ctx, req)
}

// AddCalls gets all the calls that were made to Add.
// Check the length with:
//
//	len(mockedKvClient.AddCalls())
func (mock *KvClientMock) AddCalls() []struct {
	Ctx context.Context
	Req *memdx.AddRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.AddRequest
	}
	mock.lockAdd.RLock()
	calls = mock.calls.Add
	mock.lockAdd.RUnlock()
	return calls
}

// Append calls AppendFunc.
func (mock *KvClientMock) Append(ctx context.Context, req *memdx.AppendRequest) (*memdx.AppendResponse, error) {
	if mock.AppendFunc == nil {
		panic("KvClientMock.AppendFunc: method is nil but KvClient.Append was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.AppendRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockAppend.Lock()
	mock.calls.Append = append(mock.calls.Append, callInfo)
	mock.lockAppend.Unlock()
	return mock.AppendFunc(ctx, req)
}

// AppendCalls gets all the calls that were made to Append.
// Check the length with:
//
//	len(mockedKvClient.AppendCalls())
func (mock *KvClientMock) AppendCalls() []struct {
	Ctx context.Context
	Req *memdx.AppendRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.AppendRequest
	}
	mock.lockAppend.RLock()
	calls = mock.calls.Append
	mock.lockAppend.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *KvClientMock) Close() error {
	if mock.CloseFunc == nil {
		panic("KvClientMock.CloseFunc: method is nil but KvClient.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedKvClient.CloseCalls())
func (mock *KvClientMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Decrement calls DecrementFunc.
func (mock *KvClientMock) Decrement(ctx context.Context, req *memdx.DecrementRequest) (*memdx.DecrementResponse, error) {
	if mock.DecrementFunc == nil {
		panic("KvClientMock.DecrementFunc: method is nil but KvClient.Decrement was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.DecrementRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockDecrement.Lock()
	mock.calls.Decrement = append(mock.calls.Decrement, callInfo)
	mock.lockDecrement.Unlock()
	return mock.DecrementFunc(ctx, req)
}

// DecrementCalls gets all the calls that were made to Decrement.
// Check the length with:
//
//	len(mockedKvClient.DecrementCalls())
func (mock *KvClientMock) DecrementCalls() []struct {
	Ctx context.Context
	Req *memdx.DecrementRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.DecrementRequest
	}
	mock.lockDecrement.RLock()
	calls = mock.calls.Decrement
	mock.lockDecrement.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *KvClientMock) Delete(ctx context.Context, req *memdx.DeleteRequest) (*memdx.DeleteResponse, error) {
	if mock.DeleteFunc == nil {
		panic("KvClientMock.DeleteFunc: method is nil but KvClient.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.DeleteRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, req)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedKvClient.DeleteCalls())
func (mock *KvClientMock) DeleteCalls() []struct {
	Ctx context.Context
	Req *memdx.DeleteRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.DeleteRequest
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// DeleteMeta calls DeleteMetaFunc.
func (mock *KvClientMock) DeleteMeta(ctx context.Context, req *memdx.DeleteMetaRequest) (*memdx.DeleteMetaResponse, error) {
	if mock.DeleteMetaFunc == nil {
		panic("KvClientMock.DeleteMetaFunc: method is nil but KvClient.DeleteMeta was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.DeleteMetaRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockDeleteMeta.Lock()
	mock.calls.DeleteMeta = append(mock.calls.DeleteMeta, callInfo)
	mock.lockDeleteMeta.Unlock()
	return mock.DeleteMetaFunc(ctx, req)
}

// DeleteMetaCalls gets all the calls that were made to DeleteMeta.
// Check the length with:
//
//	len(mockedKvClient.DeleteMetaCalls())
func (mock *KvClientMock) DeleteMetaCalls() []struct {
	Ctx context.Context
	Req *memdx.DeleteMetaRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.DeleteMetaRequest
	}
	mock.lockDeleteMeta.RLock()
	calls = mock.calls.DeleteMeta
	mock.lockDeleteMeta.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *KvClientMock) Get(ctx context.Context, req *memdx.GetRequest) (*memdx.GetResponse, error) {
	if mock.GetFunc == nil {
		panic("KvClientMock.GetFunc: method is nil but KvClient.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, req)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedKvClient.GetCalls())
func (mock *KvClientMock) GetCalls() []struct {
	Ctx context.Context
	Req *memdx.GetRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetRequest
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetAndLock calls GetAndLockFunc.
func (mock *KvClientMock) GetAndLock(ctx context.Context, req *memdx.GetAndLockRequest) (*memdx.GetAndLockResponse, error) {
	if mock.GetAndLockFunc == nil {
		panic("KvClientMock.GetAndLockFunc: method is nil but KvClient.GetAndLock was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetAndLockRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetAndLock.Lock()
	mock.calls.GetAndLock = append(mock.calls.GetAndLock, callInfo)
	mock.lockGetAndLock.Unlock()
	return mock.GetAndLockFunc(ctx, req)
}

// GetAndLockCalls gets all the calls that were made to GetAndLock.
// Check the length with:
//
//	len(mockedKvClient.GetAndLockCalls())
func (mock *KvClientMock) GetAndLockCalls() []struct {
	Ctx context.Context
	Req *memdx.GetAndLockRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetAndLockRequest
	}
	mock.lockGetAndLock.RLock()
	calls = mock.calls.GetAndLock
	mock.lockGetAndLock.RUnlock()
	return calls
}

// GetAndTouch calls GetAndTouchFunc.
func (mock *KvClientMock) GetAndTouch(ctx context.Context, req *memdx.GetAndTouchRequest) (*memdx.GetAndTouchResponse, error) {
	if mock.GetAndTouchFunc == nil {
		panic("KvClientMock.GetAndTouchFunc: method is nil but KvClient.GetAndTouch was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetAndTouchRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetAndTouch.Lock()
	mock.calls.GetAndTouch = append(mock.calls.GetAndTouch, callInfo)
	mock.lockGetAndTouch.Unlock()
	return mock.GetAndTouchFunc(ctx, req)
}

// GetAndTouchCalls gets all the calls that were made to GetAndTouch.
// Check the length with:
//
//	len(mockedKvClient.GetAndTouchCalls())
func (mock *KvClientMock) GetAndTouchCalls() []struct {
	Ctx context.Context
	Req *memdx.GetAndTouchRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetAndTouchRequest
	}
	mock.lockGetAndTouch.RLock()
	calls = mock.calls.GetAndTouch
	mock.lockGetAndTouch.RUnlock()
	return calls
}

// GetClusterConfig calls GetClusterConfigFunc.
func (mock *KvClientMock) GetClusterConfig(ctx context.Context, req *memdx.GetClusterConfigRequest) ([]byte, error) {
	if mock.GetClusterConfigFunc == nil {
		panic("KvClientMock.GetClusterConfigFunc: method is nil but KvClient.GetClusterConfig was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetClusterConfigRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetClusterConfig.Lock()
	mock.calls.GetClusterConfig = append(mock.calls.GetClusterConfig, callInfo)
	mock.lockGetClusterConfig.Unlock()
	return mock.GetClusterConfigFunc(ctx, req)
}

// GetClusterConfigCalls gets all the calls that were made to GetClusterConfig.
// Check the length with:
//
//	len(mockedKvClient.GetClusterConfigCalls())
func (mock *KvClientMock) GetClusterConfigCalls() []struct {
	Ctx context.Context
	Req *memdx.GetClusterConfigRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetClusterConfigRequest
	}
	mock.lockGetClusterConfig.RLock()
	calls = mock.calls.GetClusterConfig
	mock.lockGetClusterConfig.RUnlock()
	return calls
}

// GetCollectionID calls GetCollectionIDFunc.
func (mock *KvClientMock) GetCollectionID(ctx context.Context, req *memdx.GetCollectionIDRequest) (*memdx.GetCollectionIDResponse, error) {
	if mock.GetCollectionIDFunc == nil {
		panic("KvClientMock.GetCollectionIDFunc: method is nil but KvClient.GetCollectionID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetCollectionIDRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetCollectionID.Lock()
	mock.calls.GetCollectionID = append(mock.calls.GetCollectionID, callInfo)
	mock.lockGetCollectionID.Unlock()
	return mock.GetCollectionIDFunc(ctx, req)
}

// GetCollectionIDCalls gets all the calls that were made to GetCollectionID.
// Check the length with:
//
//	len(mockedKvClient.GetCollectionIDCalls())
func (mock *KvClientMock) GetCollectionIDCalls() []struct {
	Ctx context.Context
	Req *memdx.GetCollectionIDRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetCollectionIDRequest
	}
	mock.lockGetCollectionID.RLock()
	calls = mock.calls.GetCollectionID
	mock.lockGetCollectionID.RUnlock()
	return calls
}

// GetMeta calls GetMetaFunc.
func (mock *KvClientMock) GetMeta(ctx context.Context, req *memdx.GetMetaRequest) (*memdx.GetMetaResponse, error) {
	if mock.GetMetaFunc == nil {
		panic("KvClientMock.GetMetaFunc: method is nil but KvClient.GetMeta was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetMetaRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetMeta.Lock()
	mock.calls.GetMeta = append(mock.calls.GetMeta, callInfo)
	mock.lockGetMeta.Unlock()
	return mock.GetMetaFunc(ctx, req)
}

// GetMetaCalls gets all the calls that were made to GetMeta.
// Check the length with:
//
//	len(mockedKvClient.GetMetaCalls())
func (mock *KvClientMock) GetMetaCalls() []struct {
	Ctx context.Context
	Req *memdx.GetMetaRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetMetaRequest
	}
	mock.lockGetMeta.RLock()
	calls = mock.calls.GetMeta
	mock.lockGetMeta.RUnlock()
	return calls
}

// GetRandom calls GetRandomFunc.
func (mock *KvClientMock) GetRandom(ctx context.Context, req *memdx.GetRandomRequest) (*memdx.GetRandomResponse, error) {
	if mock.GetRandomFunc == nil {
		panic("KvClientMock.GetRandomFunc: method is nil but KvClient.GetRandom was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetRandomRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetRandom.Lock()
	mock.calls.GetRandom = append(mock.calls.GetRandom, callInfo)
	mock.lockGetRandom.Unlock()
	return mock.GetRandomFunc(ctx, req)
}

// GetRandomCalls gets all the calls that were made to GetRandom.
// Check the length with:
//
//	len(mockedKvClient.GetRandomCalls())
func (mock *KvClientMock) GetRandomCalls() []struct {
	Ctx context.Context
	Req *memdx.GetRandomRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetRandomRequest
	}
	mock.lockGetRandom.RLock()
	calls = mock.calls.GetRandom
	mock.lockGetRandom.RUnlock()
	return calls
}

// GetReplica calls GetReplicaFunc.
func (mock *KvClientMock) GetReplica(ctx context.Context, req *memdx.GetReplicaRequest) (*memdx.GetReplicaResponse, error) {
	if mock.GetReplicaFunc == nil {
		panic("KvClientMock.GetReplicaFunc: method is nil but KvClient.GetReplica was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetReplicaRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetReplica.Lock()
	mock.calls.GetReplica = append(mock.calls.GetReplica, callInfo)
	mock.lockGetReplica.Unlock()
	return mock.GetReplicaFunc(ctx, req)
}

// GetReplicaCalls gets all the calls that were made to GetReplica.
// Check the length with:
//
//	len(mockedKvClient.GetReplicaCalls())
func (mock *KvClientMock) GetReplicaCalls() []struct {
	Ctx context.Context
	Req *memdx.GetReplicaRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetReplicaRequest
	}
	mock.lockGetReplica.RLock()
	calls = mock.calls.GetReplica
	mock.lockGetReplica.RUnlock()
	return calls
}

// HasFeature calls HasFeatureFunc.
func (mock *KvClientMock) HasFeature(feat memdx.HelloFeature) bool {
	if mock.HasFeatureFunc == nil {
		panic("KvClientMock.HasFeatureFunc: method is nil but KvClient.HasFeature was just called")
	}
	callInfo := struct {
		Feat memdx.HelloFeature
	}{
		Feat: feat,
	}
	mock.lockHasFeature.Lock()
	mock.calls.HasFeature = append(mock.calls.HasFeature, callInfo)
	mock.lockHasFeature.Unlock()
	return mock.HasFeatureFunc(feat)
}

// HasFeatureCalls gets all the calls that were made to HasFeature.
// Check the length with:
//
//	len(mockedKvClient.HasFeatureCalls())
func (mock *KvClientMock) HasFeatureCalls() []struct {
	Feat memdx.HelloFeature
} {
	var calls []struct {
		Feat memdx.HelloFeature
	}
	mock.lockHasFeature.RLock()
	calls = mock.calls.HasFeature
	mock.lockHasFeature.RUnlock()
	return calls
}

// Increment calls IncrementFunc.
func (mock *KvClientMock) Increment(ctx context.Context, req *memdx.IncrementRequest) (*memdx.IncrementResponse, error) {
	if mock.IncrementFunc == nil {
		panic("KvClientMock.IncrementFunc: method is nil but KvClient.Increment was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.IncrementRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockIncrement.Lock()
	mock.calls.Increment = append(mock.calls.Increment, callInfo)
	mock.lockIncrement.Unlock()
	return mock.IncrementFunc(ctx, req)
}

// IncrementCalls gets all the calls that were made to Increment.
// Check the length with:
//
//	len(mockedKvClient.IncrementCalls())
func (mock *KvClientMock) IncrementCalls() []struct {
	Ctx context.Context
	Req *memdx.IncrementRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.IncrementRequest
	}
	mock.lockIncrement.RLock()
	calls = mock.calls.Increment
	mock.lockIncrement.RUnlock()
	return calls
}

// LoadFactor calls LoadFactorFunc.
func (mock *KvClientMock) LoadFactor() float64 {
	if mock.LoadFactorFunc == nil {
		panic("KvClientMock.LoadFactorFunc: method is nil but KvClient.LoadFactor was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLoadFactor.Lock()
	mock.calls.LoadFactor = append(mock.calls.LoadFactor, callInfo)
	mock.lockLoadFactor.Unlock()
	return mock.LoadFactorFunc()
}

// LoadFactorCalls gets all the calls that were made to LoadFactor.
// Check the length with:
//
//	len(mockedKvClient.LoadFactorCalls())
func (mock *KvClientMock) LoadFactorCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLoadFactor.RLock()
	calls = mock.calls.LoadFactor
	mock.lockLoadFactor.RUnlock()
	return calls
}

// LookupIn calls LookupInFunc.
func (mock *KvClientMock) LookupIn(ctx context.Context, req *memdx.LookupInRequest) (*memdx.LookupInResponse, error) {
	if mock.LookupInFunc == nil {
		panic("KvClientMock.LookupInFunc: method is nil but KvClient.LookupIn was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.LookupInRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockLookupIn.Lock()
	mock.calls.LookupIn = append(mock.calls.LookupIn, callInfo)
	mock.lockLookupIn.Unlock()
	return mock.LookupInFunc(ctx, req)
}

// LookupInCalls gets all the calls that were made to LookupIn.
// Check the length with:
//
//	len(mockedKvClient.LookupInCalls())
func (mock *KvClientMock) LookupInCalls() []struct {
	Ctx context.Context
	Req *memdx.LookupInRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.LookupInRequest
	}
	mock.lockLookupIn.RLock()
	calls = mock.calls.LookupIn
	mock.lockLookupIn.RUnlock()
	return calls
}

// MutateIn calls MutateInFunc.
func (mock *KvClientMock) MutateIn(ctx context.Context, req *memdx.MutateInRequest) (*memdx.MutateInResponse, error) {
	if mock.MutateInFunc == nil {
		panic("KvClientMock.MutateInFunc: method is nil but KvClient.MutateIn was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.MutateInRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockMutateIn.Lock()
	mock.calls.MutateIn = append(mock.calls.MutateIn, callInfo)
	mock.lockMutateIn.Unlock()
	return mock.MutateInFunc(ctx, req)
}

// MutateInCalls gets all the calls that were made to MutateIn.
// Check the length with:
//
//	len(mockedKvClient.MutateInCalls())
func (mock *KvClientMock) MutateInCalls() []struct {
	Ctx context.Context
	Req *memdx.MutateInRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.MutateInRequest
	}
	mock.lockMutateIn.RLock()
	calls = mock.calls.MutateIn
	mock.lockMutateIn.RUnlock()
	return calls
}

// Prepend calls PrependFunc.
func (mock *KvClientMock) Prepend(ctx context.Context, req *memdx.PrependRequest) (*memdx.PrependResponse, error) {
	if mock.PrependFunc == nil {
		panic("KvClientMock.PrependFunc: method is nil but KvClient.Prepend was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.PrependRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockPrepend.Lock()
	mock.calls.Prepend = append(mock.calls.Prepend, callInfo)
	mock.lockPrepend.Unlock()
	return mock.PrependFunc(ctx, req)
}

// PrependCalls gets all the calls that were made to Prepend.
// Check the length with:
//
//	len(mockedKvClient.PrependCalls())
func (mock *KvClientMock) PrependCalls() []struct {
	Ctx context.Context
	Req *memdx.PrependRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.PrependRequest
	}
	mock.lockPrepend.RLock()
	calls = mock.calls.Prepend
	mock.lockPrepend.RUnlock()
	return calls
}

// Reconfigure calls ReconfigureFunc.
func (mock *KvClientMock) Reconfigure(config *KvClientConfig, cb func(error)) error {
	if mock.ReconfigureFunc == nil {
		panic("KvClientMock.ReconfigureFunc: method is nil but KvClient.Reconfigure was just called")
	}
	callInfo := struct {
		Config *KvClientConfig
		Cb     func(error)
	}{
		Config: config,
		Cb:     cb,
	}
	mock.lockReconfigure.Lock()
	mock.calls.Reconfigure = append(mock.calls.Reconfigure, callInfo)
	mock.lockReconfigure.Unlock()
	return mock.ReconfigureFunc(config, cb)
}

// ReconfigureCalls gets all the calls that were made to Reconfigure.
// Check the length with:
//
//	len(mockedKvClient.ReconfigureCalls())
func (mock *KvClientMock) ReconfigureCalls() []struct {
	Config *KvClientConfig
	Cb     func(error)
} {
	var calls []struct {
		Config *KvClientConfig
		Cb     func(error)
	}
	mock.lockReconfigure.RLock()
	calls = mock.calls.Reconfigure
	mock.lockReconfigure.RUnlock()
	return calls
}

// RemoteAddress calls RemoteAddressFunc.
func (mock *KvClientMock) RemoteAddress() string {
	if mock.RemoteAddressFunc == nil {
		panic("KvClientMock.RemoteAddressFunc: method is nil but KvClient.RemoteAddress was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRemoteAddress.Lock()
	mock.calls.RemoteAddress = append(mock.calls.RemoteAddress, callInfo)
	mock.lockRemoteAddress.Unlock()
	return mock.RemoteAddressFunc()
}

// RemoteAddressCalls gets all the calls that were made to RemoteAddress.
// Check the length with:
//
//	len(mockedKvClient.RemoteAddressCalls())
func (mock *KvClientMock) RemoteAddressCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRemoteAddress.RLock()
	calls = mock.calls.RemoteAddress
	mock.lockRemoteAddress.RUnlock()
	return calls
}

// Replace calls ReplaceFunc.
func (mock *KvClientMock) Replace(ctx context.Context, req *memdx.ReplaceRequest) (*memdx.ReplaceResponse, error) {
	if mock.ReplaceFunc == nil {
		panic("KvClientMock.ReplaceFunc: method is nil but KvClient.Replace was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.ReplaceRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockReplace.Lock()
	mock.calls.Replace = append(mock.calls.Replace, callInfo)
	mock.lockReplace.Unlock()
	return mock.ReplaceFunc(ctx, req)
}

// ReplaceCalls gets all the calls that were made to Replace.
// Check the length with:
//
//	len(mockedKvClient.ReplaceCalls())
func (mock *KvClientMock) ReplaceCalls() []struct {
	Ctx context.Context
	Req *memdx.ReplaceRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.ReplaceRequest
	}
	mock.lockReplace.RLock()
	calls = mock.calls.Replace
	mock.lockReplace.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *KvClientMock) Set(ctx context.Context, req *memdx.SetRequest) (*memdx.SetResponse, error) {
	if mock.SetFunc == nil {
		panic("KvClientMock.SetFunc: method is nil but KvClient.Set was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.SetRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	return mock.SetFunc(ctx, req)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//
//	len(mockedKvClient.SetCalls())
func (mock *KvClientMock) SetCalls() []struct {
	Ctx context.Context
	Req *memdx.SetRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.SetRequest
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}

// SetMeta calls SetMetaFunc.
func (mock *KvClientMock) SetMeta(ctx context.Context, req *memdx.SetMetaRequest) (*memdx.SetMetaResponse, error) {
	if mock.SetMetaFunc == nil {
		panic("KvClientMock.SetMetaFunc: method is nil but KvClient.SetMeta was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.SetMetaRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockSetMeta.Lock()
	mock.calls.SetMeta = append(mock.calls.SetMeta, callInfo)
	mock.lockSetMeta.Unlock()
	return mock.SetMetaFunc(ctx, req)
}

// SetMetaCalls gets all the calls that were made to SetMeta.
// Check the length with:
//
//	len(mockedKvClient.SetMetaCalls())
func (mock *KvClientMock) SetMetaCalls() []struct {
	Ctx context.Context
	Req *memdx.SetMetaRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.SetMetaRequest
	}
	mock.lockSetMeta.RLock()
	calls = mock.calls.SetMeta
	mock.lockSetMeta.RUnlock()
	return calls
}

// Touch calls TouchFunc.
func (mock *KvClientMock) Touch(ctx context.Context, req *memdx.TouchRequest) (*memdx.TouchResponse, error) {
	if mock.TouchFunc == nil {
		panic("KvClientMock.TouchFunc: method is nil but KvClient.Touch was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.TouchRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockTouch.Lock()
	mock.calls.Touch = append(mock.calls.Touch, callInfo)
	mock.lockTouch.Unlock()
	return mock.TouchFunc(ctx, req)
}

// TouchCalls gets all the calls that were made to Touch.
// Check the length with:
//
//	len(mockedKvClient.TouchCalls())
func (mock *KvClientMock) TouchCalls() []struct {
	Ctx context.Context
	Req *memdx.TouchRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.TouchRequest
	}
	mock.lockTouch.RLock()
	calls = mock.calls.Touch
	mock.lockTouch.RUnlock()
	return calls
}

// Unlock calls UnlockFunc.
func (mock *KvClientMock) Unlock(ctx context.Context, req *memdx.UnlockRequest) (*memdx.UnlockResponse, error) {
	if mock.UnlockFunc == nil {
		panic("KvClientMock.UnlockFunc: method is nil but KvClient.Unlock was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.UnlockRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockUnlock.Lock()
	mock.calls.Unlock = append(mock.calls.Unlock, callInfo)
	mock.lockUnlock.Unlock()
	return mock.UnlockFunc(ctx, req)
}

// UnlockCalls gets all the calls that were made to Unlock.
// Check the length with:
//
//	len(mockedKvClient.UnlockCalls())
func (mock *KvClientMock) UnlockCalls() []struct {
	Ctx context.Context
	Req *memdx.UnlockRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.UnlockRequest
	}
	mock.lockUnlock.RLock()
	calls = mock.calls.Unlock
	mock.lockUnlock.RUnlock()
	return calls
}

// Ensure, that MemdxDispatcherCloserMock does implement MemdxDispatcherCloser.
// If this is not the case, regenerate this file with moq.
var _ MemdxDispatcherCloser = &MemdxDispatcherCloserMock{}

// MemdxDispatcherCloserMock is a mock implementation of MemdxDispatcherCloser.
//
//	func TestSomethingThatUsesMemdxDispatcherCloser(t *testing.T) {
//
//		// make and configure a mocked MemdxDispatcherCloser
//		mockedMemdxDispatcherCloser := &MemdxDispatcherCloserMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			DispatchFunc: func(packet *memdx.Packet, dispatchCallback memdx.DispatchCallback) (memdx.PendingOp, error) {
//				panic("mock out the Dispatch method")
//			},
//			LocalAddrFunc: func() string {
//				panic("mock out the LocalAddr method")
//			},
//			RemoteAddrFunc: func() string {
//				panic("mock out the RemoteAddr method")
//			},
//		}
//
//		// use mockedMemdxDispatcherCloser in code that requires MemdxDispatcherCloser
//		// and then make assertions.
//
//	}
type MemdxDispatcherCloserMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// DispatchFunc mocks the Dispatch method.
	DispatchFunc func(packet *memdx.Packet, dispatchCallback memdx.DispatchCallback) (memdx.PendingOp, error)

	// LocalAddrFunc mocks the LocalAddr method.
	LocalAddrFunc func() string

	// RemoteAddrFunc mocks the RemoteAddr method.
	RemoteAddrFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Dispatch holds details about calls to the Dispatch method.
		Dispatch []struct {
			// Packet is the packet argument value.
			Packet *memdx.Packet
			// DispatchCallback is the dispatchCallback argument value.
			DispatchCallback memdx.DispatchCallback
		}
		// LocalAddr holds details about calls to the LocalAddr method.
		LocalAddr []struct {
		}
		// RemoteAddr holds details about calls to the RemoteAddr method.
		RemoteAddr []struct {
		}
	}
	lockClose      sync.RWMutex
	lockDispatch   sync.RWMutex
	lockLocalAddr  sync.RWMutex
	lockRemoteAddr sync.RWMutex
}

// Close calls CloseFunc.
func (mock *MemdxDispatcherCloserMock) Close() error {
	if mock.CloseFunc == nil {
		panic("MemdxDispatcherCloserMock.CloseFunc: method is nil but MemdxDispatcherCloser.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedMemdxDispatcherCloser.CloseCalls())
func (mock *MemdxDispatcherCloserMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Dispatch calls DispatchFunc.
func (mock *MemdxDispatcherCloserMock) Dispatch(packet *memdx.Packet, dispatchCallback memdx.DispatchCallback) (memdx.PendingOp, error) {
	if mock.DispatchFunc == nil {
		panic("MemdxDispatcherCloserMock.DispatchFunc: method is nil but MemdxDispatcherCloser.Dispatch was just called")
	}
	callInfo := struct {
		Packet           *memdx.Packet
		DispatchCallback memdx.DispatchCallback
	}{
		Packet:           packet,
		DispatchCallback: dispatchCallback,
	}
	mock.lockDispatch.Lock()
	mock.calls.Dispatch = append(mock.calls.Dispatch, callInfo)
	mock.lockDispatch.Unlock()
	return mock.DispatchFunc(packet, dispatchCallback)
}

// DispatchCalls gets all the calls that were made to Dispatch.
// Check the length with:
//
//	len(mockedMemdxDispatcherCloser.DispatchCalls())
func (mock *MemdxDispatcherCloserMock) DispatchCalls() []struct {
	Packet           *memdx.Packet
	DispatchCallback memdx.DispatchCallback
} {
	var calls []struct {
		Packet           *memdx.Packet
		DispatchCallback memdx.DispatchCallback
	}
	mock.lockDispatch.RLock()
	calls = mock.calls.Dispatch
	mock.lockDispatch.RUnlock()
	return calls
}

// LocalAddr calls LocalAddrFunc.
func (mock *MemdxDispatcherCloserMock) LocalAddr() string {
	if mock.LocalAddrFunc == nil {
		panic("MemdxDispatcherCloserMock.LocalAddrFunc: method is nil but MemdxDispatcherCloser.LocalAddr was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLocalAddr.Lock()
	mock.calls.LocalAddr = append(mock.calls.LocalAddr, callInfo)
	mock.lockLocalAddr.Unlock()
	return mock.LocalAddrFunc()
}

// LocalAddrCalls gets all the calls that were made to LocalAddr.
// Check the length with:
//
//	len(mockedMemdxDispatcherCloser.LocalAddrCalls())
func (mock *MemdxDispatcherCloserMock) LocalAddrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLocalAddr.RLock()
	calls = mock.calls.LocalAddr
	mock.lockLocalAddr.RUnlock()
	return calls
}

// RemoteAddr calls RemoteAddrFunc.
func (mock *MemdxDispatcherCloserMock) RemoteAddr() string {
	if mock.RemoteAddrFunc == nil {
		panic("MemdxDispatcherCloserMock.RemoteAddrFunc: method is nil but MemdxDispatcherCloser.RemoteAddr was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRemoteAddr.Lock()
	mock.calls.RemoteAddr = append(mock.calls.RemoteAddr, callInfo)
	mock.lockRemoteAddr.Unlock()
	return mock.RemoteAddrFunc()
}

// RemoteAddrCalls gets all the calls that were made to RemoteAddr.
// Check the length with:
//
//	len(mockedMemdxDispatcherCloser.RemoteAddrCalls())
func (mock *MemdxDispatcherCloserMock) RemoteAddrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRemoteAddr.RLock()
	calls = mock.calls.RemoteAddr
	mock.lockRemoteAddr.RUnlock()
	return calls
}
