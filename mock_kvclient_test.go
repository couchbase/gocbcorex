// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package gocbcorex

import (
	"context"
	"github.com/couchbase/gocbcorex/memdx"
	"net"
	"sync"
)

// Ensure, that KvClientMock does implement KvClient.
// If this is not the case, regenerate this file with moq.
var _ KvClient = &KvClientMock{}

// KvClientMock is a mock implementation of KvClient.
//
//	func TestSomethingThatUsesKvClient(t *testing.T) {
//
//		// make and configure a mocked KvClient
//		mockedKvClient := &KvClientMock{
//			AddFunc: func(ctx context.Context, req *memdx.AddRequest) (*memdx.AddResponse, error) {
//				panic("mock out the Add method")
//			},
//			AddWithMetaFunc: func(ctx context.Context, req *memdx.AddWithMetaRequest) (*memdx.AddWithMetaResponse, error) {
//				panic("mock out the AddWithMeta method")
//			},
//			AppendFunc: func(ctx context.Context, req *memdx.AppendRequest) (*memdx.AppendResponse, error) {
//				panic("mock out the Append method")
//			},
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			DecrementFunc: func(ctx context.Context, req *memdx.DecrementRequest) (*memdx.DecrementResponse, error) {
//				panic("mock out the Decrement method")
//			},
//			DeleteFunc: func(ctx context.Context, req *memdx.DeleteRequest) (*memdx.DeleteResponse, error) {
//				panic("mock out the Delete method")
//			},
//			DeleteWithMetaFunc: func(ctx context.Context, req *memdx.DeleteWithMetaRequest) (*memdx.DeleteWithMetaResponse, error) {
//				panic("mock out the DeleteWithMeta method")
//			},
//			DispatchFunc: func(packet *memdx.Packet, dispatchCallback memdx.DispatchCallback) (memdx.PendingOp, error) {
//				panic("mock out the Dispatch method")
//			},
//			GetFunc: func(ctx context.Context, req *memdx.GetRequest) (*memdx.GetResponse, error) {
//				panic("mock out the Get method")
//			},
//			GetAndLockFunc: func(ctx context.Context, req *memdx.GetAndLockRequest) (*memdx.GetAndLockResponse, error) {
//				panic("mock out the GetAndLock method")
//			},
//			GetAndTouchFunc: func(ctx context.Context, req *memdx.GetAndTouchRequest) (*memdx.GetAndTouchResponse, error) {
//				panic("mock out the GetAndTouch method")
//			},
//			GetClusterConfigFunc: func(ctx context.Context, req *memdx.GetClusterConfigRequest) (*memdx.GetClusterConfigResponse, error) {
//				panic("mock out the GetClusterConfig method")
//			},
//			GetCollectionIDFunc: func(ctx context.Context, req *memdx.GetCollectionIDRequest) (*memdx.GetCollectionIDResponse, error) {
//				panic("mock out the GetCollectionID method")
//			},
//			GetExFunc: func(ctx context.Context, req *memdx.GetExRequest) (*memdx.GetExResponse, error) {
//				panic("mock out the GetEx method")
//			},
//			GetMetaFunc: func(ctx context.Context, req *memdx.GetMetaRequest) (*memdx.GetMetaResponse, error) {
//				panic("mock out the GetMeta method")
//			},
//			GetRandomFunc: func(ctx context.Context, req *memdx.GetRandomRequest) (*memdx.GetRandomResponse, error) {
//				panic("mock out the GetRandom method")
//			},
//			GetReplicaFunc: func(ctx context.Context, req *memdx.GetReplicaRequest) (*memdx.GetReplicaResponse, error) {
//				panic("mock out the GetReplica method")
//			},
//			HasFeatureFunc: func(feat memdx.HelloFeature) bool {
//				panic("mock out the HasFeature method")
//			},
//			IncrementFunc: func(ctx context.Context, req *memdx.IncrementRequest) (*memdx.IncrementResponse, error) {
//				panic("mock out the Increment method")
//			},
//			LoadFactorFunc: func() float64 {
//				panic("mock out the LoadFactor method")
//			},
//			LocalAddrFunc: func() net.Addr {
//				panic("mock out the LocalAddr method")
//			},
//			LookupInFunc: func(ctx context.Context, req *memdx.LookupInRequest) (*memdx.LookupInResponse, error) {
//				panic("mock out the LookupIn method")
//			},
//			MutateInFunc: func(ctx context.Context, req *memdx.MutateInRequest) (*memdx.MutateInResponse, error) {
//				panic("mock out the MutateIn method")
//			},
//			PrependFunc: func(ctx context.Context, req *memdx.PrependRequest) (*memdx.PrependResponse, error) {
//				panic("mock out the Prepend method")
//			},
//			RangeScanCancelFunc: func(ctx context.Context, req *memdx.RangeScanCancelRequest) (*memdx.RangeScanCancelResponse, error) {
//				panic("mock out the RangeScanCancel method")
//			},
//			RangeScanContinueFunc: func(ctx context.Context, req *memdx.RangeScanContinueRequest, dataCb func(*memdx.RangeScanDataResponse) error) (*memdx.RangeScanActionResponse, error) {
//				panic("mock out the RangeScanContinue method")
//			},
//			RangeScanCreateFunc: func(ctx context.Context, req *memdx.RangeScanCreateRequest) (*memdx.RangeScanCreateResponse, error) {
//				panic("mock out the RangeScanCreate method")
//			},
//			ReconfigureFunc: func(config *KvClientConfig, cb func(error)) error {
//				panic("mock out the Reconfigure method")
//			},
//			RemoteAddrFunc: func() net.Addr {
//				panic("mock out the RemoteAddr method")
//			},
//			RemoteHostnameFunc: func() string {
//				panic("mock out the RemoteHostname method")
//			},
//			ReplaceFunc: func(ctx context.Context, req *memdx.ReplaceRequest) (*memdx.ReplaceResponse, error) {
//				panic("mock out the Replace method")
//			},
//			SetFunc: func(ctx context.Context, req *memdx.SetRequest) (*memdx.SetResponse, error) {
//				panic("mock out the Set method")
//			},
//			SetWithMetaFunc: func(ctx context.Context, req *memdx.SetWithMetaRequest) (*memdx.SetWithMetaResponse, error) {
//				panic("mock out the SetWithMeta method")
//			},
//			StatsFunc: func(ctx context.Context, req *memdx.StatsRequest, dataCb func(*memdx.StatsDataResponse) error) (*memdx.StatsActionResponse, error) {
//				panic("mock out the Stats method")
//			},
//			TouchFunc: func(ctx context.Context, req *memdx.TouchRequest) (*memdx.TouchResponse, error) {
//				panic("mock out the Touch method")
//			},
//			UnlockFunc: func(ctx context.Context, req *memdx.UnlockRequest) (*memdx.UnlockResponse, error) {
//				panic("mock out the Unlock method")
//			},
//		}
//
//		// use mockedKvClient in code that requires KvClient
//		// and then make assertions.
//
//	}
type KvClientMock struct {
	// AddFunc mocks the Add method.
	AddFunc func(ctx context.Context, req *memdx.AddRequest) (*memdx.AddResponse, error)

	// AddWithMetaFunc mocks the AddWithMeta method.
	AddWithMetaFunc func(ctx context.Context, req *memdx.AddWithMetaRequest) (*memdx.AddWithMetaResponse, error)

	// AppendFunc mocks the Append method.
	AppendFunc func(ctx context.Context, req *memdx.AppendRequest) (*memdx.AppendResponse, error)

	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// DecrementFunc mocks the Decrement method.
	DecrementFunc func(ctx context.Context, req *memdx.DecrementRequest) (*memdx.DecrementResponse, error)

	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, req *memdx.DeleteRequest) (*memdx.DeleteResponse, error)

	// DeleteWithMetaFunc mocks the DeleteWithMeta method.
	DeleteWithMetaFunc func(ctx context.Context, req *memdx.DeleteWithMetaRequest) (*memdx.DeleteWithMetaResponse, error)

	// DispatchFunc mocks the Dispatch method.
	DispatchFunc func(packet *memdx.Packet, dispatchCallback memdx.DispatchCallback) (memdx.PendingOp, error)

	// GetFunc mocks the Get method.
	GetFunc func(ctx context.Context, req *memdx.GetRequest) (*memdx.GetResponse, error)

	// GetAndLockFunc mocks the GetAndLock method.
	GetAndLockFunc func(ctx context.Context, req *memdx.GetAndLockRequest) (*memdx.GetAndLockResponse, error)

	// GetAndTouchFunc mocks the GetAndTouch method.
	GetAndTouchFunc func(ctx context.Context, req *memdx.GetAndTouchRequest) (*memdx.GetAndTouchResponse, error)

	// GetClusterConfigFunc mocks the GetClusterConfig method.
	GetClusterConfigFunc func(ctx context.Context, req *memdx.GetClusterConfigRequest) (*memdx.GetClusterConfigResponse, error)

	// GetCollectionIDFunc mocks the GetCollectionID method.
	GetCollectionIDFunc func(ctx context.Context, req *memdx.GetCollectionIDRequest) (*memdx.GetCollectionIDResponse, error)

	// GetExFunc mocks the GetEx method.
	GetExFunc func(ctx context.Context, req *memdx.GetExRequest) (*memdx.GetExResponse, error)

	// GetMetaFunc mocks the GetMeta method.
	GetMetaFunc func(ctx context.Context, req *memdx.GetMetaRequest) (*memdx.GetMetaResponse, error)

	// GetRandomFunc mocks the GetRandom method.
	GetRandomFunc func(ctx context.Context, req *memdx.GetRandomRequest) (*memdx.GetRandomResponse, error)

	// GetReplicaFunc mocks the GetReplica method.
	GetReplicaFunc func(ctx context.Context, req *memdx.GetReplicaRequest) (*memdx.GetReplicaResponse, error)

	// HasFeatureFunc mocks the HasFeature method.
	HasFeatureFunc func(feat memdx.HelloFeature) bool

	// IncrementFunc mocks the Increment method.
	IncrementFunc func(ctx context.Context, req *memdx.IncrementRequest) (*memdx.IncrementResponse, error)

	// LoadFactorFunc mocks the LoadFactor method.
	LoadFactorFunc func() float64

	// LocalAddrFunc mocks the LocalAddr method.
	LocalAddrFunc func() net.Addr

	// LookupInFunc mocks the LookupIn method.
	LookupInFunc func(ctx context.Context, req *memdx.LookupInRequest) (*memdx.LookupInResponse, error)

	// MutateInFunc mocks the MutateIn method.
	MutateInFunc func(ctx context.Context, req *memdx.MutateInRequest) (*memdx.MutateInResponse, error)

	// PrependFunc mocks the Prepend method.
	PrependFunc func(ctx context.Context, req *memdx.PrependRequest) (*memdx.PrependResponse, error)

	// RangeScanCancelFunc mocks the RangeScanCancel method.
	RangeScanCancelFunc func(ctx context.Context, req *memdx.RangeScanCancelRequest) (*memdx.RangeScanCancelResponse, error)

	// RangeScanContinueFunc mocks the RangeScanContinue method.
	RangeScanContinueFunc func(ctx context.Context, req *memdx.RangeScanContinueRequest, dataCb func(*memdx.RangeScanDataResponse) error) (*memdx.RangeScanActionResponse, error)

	// RangeScanCreateFunc mocks the RangeScanCreate method.
	RangeScanCreateFunc func(ctx context.Context, req *memdx.RangeScanCreateRequest) (*memdx.RangeScanCreateResponse, error)

	// ReconfigureFunc mocks the Reconfigure method.
	ReconfigureFunc func(config *KvClientConfig, cb func(error)) error

	// RemoteAddrFunc mocks the RemoteAddr method.
	RemoteAddrFunc func() net.Addr

	// RemoteHostnameFunc mocks the RemoteHostname method.
	RemoteHostnameFunc func() string

	// ReplaceFunc mocks the Replace method.
	ReplaceFunc func(ctx context.Context, req *memdx.ReplaceRequest) (*memdx.ReplaceResponse, error)

	// SetFunc mocks the Set method.
	SetFunc func(ctx context.Context, req *memdx.SetRequest) (*memdx.SetResponse, error)

	// SetWithMetaFunc mocks the SetWithMeta method.
	SetWithMetaFunc func(ctx context.Context, req *memdx.SetWithMetaRequest) (*memdx.SetWithMetaResponse, error)

	// StatsFunc mocks the Stats method.
	StatsFunc func(ctx context.Context, req *memdx.StatsRequest, dataCb func(*memdx.StatsDataResponse) error) (*memdx.StatsActionResponse, error)

	// TouchFunc mocks the Touch method.
	TouchFunc func(ctx context.Context, req *memdx.TouchRequest) (*memdx.TouchResponse, error)

	// UnlockFunc mocks the Unlock method.
	UnlockFunc func(ctx context.Context, req *memdx.UnlockRequest) (*memdx.UnlockResponse, error)

	// calls tracks calls to the methods.
	calls struct {
		// Add holds details about calls to the Add method.
		Add []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.AddRequest
		}
		// AddWithMeta holds details about calls to the AddWithMeta method.
		AddWithMeta []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.AddWithMetaRequest
		}
		// Append holds details about calls to the Append method.
		Append []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.AppendRequest
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Decrement holds details about calls to the Decrement method.
		Decrement []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.DecrementRequest
		}
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.DeleteRequest
		}
		// DeleteWithMeta holds details about calls to the DeleteWithMeta method.
		DeleteWithMeta []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.DeleteWithMetaRequest
		}
		// Dispatch holds details about calls to the Dispatch method.
		Dispatch []struct {
			// Packet is the packet argument value.
			Packet *memdx.Packet
			// DispatchCallback is the dispatchCallback argument value.
			DispatchCallback memdx.DispatchCallback
		}
		// Get holds details about calls to the Get method.
		Get []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetRequest
		}
		// GetAndLock holds details about calls to the GetAndLock method.
		GetAndLock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetAndLockRequest
		}
		// GetAndTouch holds details about calls to the GetAndTouch method.
		GetAndTouch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetAndTouchRequest
		}
		// GetClusterConfig holds details about calls to the GetClusterConfig method.
		GetClusterConfig []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetClusterConfigRequest
		}
		// GetCollectionID holds details about calls to the GetCollectionID method.
		GetCollectionID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetCollectionIDRequest
		}
		// GetEx holds details about calls to the GetEx method.
		GetEx []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetExRequest
		}
		// GetMeta holds details about calls to the GetMeta method.
		GetMeta []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetMetaRequest
		}
		// GetRandom holds details about calls to the GetRandom method.
		GetRandom []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetRandomRequest
		}
		// GetReplica holds details about calls to the GetReplica method.
		GetReplica []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.GetReplicaRequest
		}
		// HasFeature holds details about calls to the HasFeature method.
		HasFeature []struct {
			// Feat is the feat argument value.
			Feat memdx.HelloFeature
		}
		// Increment holds details about calls to the Increment method.
		Increment []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.IncrementRequest
		}
		// LoadFactor holds details about calls to the LoadFactor method.
		LoadFactor []struct {
		}
		// LocalAddr holds details about calls to the LocalAddr method.
		LocalAddr []struct {
		}
		// LookupIn holds details about calls to the LookupIn method.
		LookupIn []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.LookupInRequest
		}
		// MutateIn holds details about calls to the MutateIn method.
		MutateIn []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.MutateInRequest
		}
		// Prepend holds details about calls to the Prepend method.
		Prepend []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.PrependRequest
		}
		// RangeScanCancel holds details about calls to the RangeScanCancel method.
		RangeScanCancel []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.RangeScanCancelRequest
		}
		// RangeScanContinue holds details about calls to the RangeScanContinue method.
		RangeScanContinue []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.RangeScanContinueRequest
			// DataCb is the dataCb argument value.
			DataCb func(*memdx.RangeScanDataResponse) error
		}
		// RangeScanCreate holds details about calls to the RangeScanCreate method.
		RangeScanCreate []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.RangeScanCreateRequest
		}
		// Reconfigure holds details about calls to the Reconfigure method.
		Reconfigure []struct {
			// Config is the config argument value.
			Config *KvClientConfig
			// Cb is the cb argument value.
			Cb func(error)
		}
		// RemoteAddr holds details about calls to the RemoteAddr method.
		RemoteAddr []struct {
		}
		// RemoteHostname holds details about calls to the RemoteHostname method.
		RemoteHostname []struct {
		}
		// Replace holds details about calls to the Replace method.
		Replace []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.ReplaceRequest
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.SetRequest
		}
		// SetWithMeta holds details about calls to the SetWithMeta method.
		SetWithMeta []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.SetWithMetaRequest
		}
		// Stats holds details about calls to the Stats method.
		Stats []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.StatsRequest
			// DataCb is the dataCb argument value.
			DataCb func(*memdx.StatsDataResponse) error
		}
		// Touch holds details about calls to the Touch method.
		Touch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.TouchRequest
		}
		// Unlock holds details about calls to the Unlock method.
		Unlock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Req is the req argument value.
			Req *memdx.UnlockRequest
		}
	}
	lockAdd               sync.RWMutex
	lockAddWithMeta       sync.RWMutex
	lockAppend            sync.RWMutex
	lockClose             sync.RWMutex
	lockDecrement         sync.RWMutex
	lockDelete            sync.RWMutex
	lockDeleteWithMeta    sync.RWMutex
	lockDispatch          sync.RWMutex
	lockGet               sync.RWMutex
	lockGetAndLock        sync.RWMutex
	lockGetAndTouch       sync.RWMutex
	lockGetClusterConfig  sync.RWMutex
	lockGetCollectionID   sync.RWMutex
	lockGetEx             sync.RWMutex
	lockGetMeta           sync.RWMutex
	lockGetRandom         sync.RWMutex
	lockGetReplica        sync.RWMutex
	lockHasFeature        sync.RWMutex
	lockIncrement         sync.RWMutex
	lockLoadFactor        sync.RWMutex
	lockLocalAddr         sync.RWMutex
	lockLookupIn          sync.RWMutex
	lockMutateIn          sync.RWMutex
	lockPrepend           sync.RWMutex
	lockRangeScanCancel   sync.RWMutex
	lockRangeScanContinue sync.RWMutex
	lockRangeScanCreate   sync.RWMutex
	lockReconfigure       sync.RWMutex
	lockRemoteAddr        sync.RWMutex
	lockRemoteHostname    sync.RWMutex
	lockReplace           sync.RWMutex
	lockSet               sync.RWMutex
	lockSetWithMeta       sync.RWMutex
	lockStats             sync.RWMutex
	lockTouch             sync.RWMutex
	lockUnlock            sync.RWMutex
}

// Add calls AddFunc.
func (mock *KvClientMock) Add(ctx context.Context, req *memdx.AddRequest) (*memdx.AddResponse, error) {
	if mock.AddFunc == nil {
		panic("KvClientMock.AddFunc: method is nil but KvClient.Add was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.AddRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockAdd.Lock()
	mock.calls.Add = append(mock.calls.Add, callInfo)
	mock.lockAdd.Unlock()
	return mock.AddFunc(ctx, req)
}

// AddCalls gets all the calls that were made to Add.
// Check the length with:
//
//	len(mockedKvClient.AddCalls())
func (mock *KvClientMock) AddCalls() []struct {
	Ctx context.Context
	Req *memdx.AddRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.AddRequest
	}
	mock.lockAdd.RLock()
	calls = mock.calls.Add
	mock.lockAdd.RUnlock()
	return calls
}

// AddWithMeta calls AddWithMetaFunc.
func (mock *KvClientMock) AddWithMeta(ctx context.Context, req *memdx.AddWithMetaRequest) (*memdx.AddWithMetaResponse, error) {
	if mock.AddWithMetaFunc == nil {
		panic("KvClientMock.AddWithMetaFunc: method is nil but KvClient.AddWithMeta was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.AddWithMetaRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockAddWithMeta.Lock()
	mock.calls.AddWithMeta = append(mock.calls.AddWithMeta, callInfo)
	mock.lockAddWithMeta.Unlock()
	return mock.AddWithMetaFunc(ctx, req)
}

// AddWithMetaCalls gets all the calls that were made to AddWithMeta.
// Check the length with:
//
//	len(mockedKvClient.AddWithMetaCalls())
func (mock *KvClientMock) AddWithMetaCalls() []struct {
	Ctx context.Context
	Req *memdx.AddWithMetaRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.AddWithMetaRequest
	}
	mock.lockAddWithMeta.RLock()
	calls = mock.calls.AddWithMeta
	mock.lockAddWithMeta.RUnlock()
	return calls
}

// Append calls AppendFunc.
func (mock *KvClientMock) Append(ctx context.Context, req *memdx.AppendRequest) (*memdx.AppendResponse, error) {
	if mock.AppendFunc == nil {
		panic("KvClientMock.AppendFunc: method is nil but KvClient.Append was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.AppendRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockAppend.Lock()
	mock.calls.Append = append(mock.calls.Append, callInfo)
	mock.lockAppend.Unlock()
	return mock.AppendFunc(ctx, req)
}

// AppendCalls gets all the calls that were made to Append.
// Check the length with:
//
//	len(mockedKvClient.AppendCalls())
func (mock *KvClientMock) AppendCalls() []struct {
	Ctx context.Context
	Req *memdx.AppendRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.AppendRequest
	}
	mock.lockAppend.RLock()
	calls = mock.calls.Append
	mock.lockAppend.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *KvClientMock) Close() error {
	if mock.CloseFunc == nil {
		panic("KvClientMock.CloseFunc: method is nil but KvClient.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedKvClient.CloseCalls())
func (mock *KvClientMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Decrement calls DecrementFunc.
func (mock *KvClientMock) Decrement(ctx context.Context, req *memdx.DecrementRequest) (*memdx.DecrementResponse, error) {
	if mock.DecrementFunc == nil {
		panic("KvClientMock.DecrementFunc: method is nil but KvClient.Decrement was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.DecrementRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockDecrement.Lock()
	mock.calls.Decrement = append(mock.calls.Decrement, callInfo)
	mock.lockDecrement.Unlock()
	return mock.DecrementFunc(ctx, req)
}

// DecrementCalls gets all the calls that were made to Decrement.
// Check the length with:
//
//	len(mockedKvClient.DecrementCalls())
func (mock *KvClientMock) DecrementCalls() []struct {
	Ctx context.Context
	Req *memdx.DecrementRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.DecrementRequest
	}
	mock.lockDecrement.RLock()
	calls = mock.calls.Decrement
	mock.lockDecrement.RUnlock()
	return calls
}

// Delete calls DeleteFunc.
func (mock *KvClientMock) Delete(ctx context.Context, req *memdx.DeleteRequest) (*memdx.DeleteResponse, error) {
	if mock.DeleteFunc == nil {
		panic("KvClientMock.DeleteFunc: method is nil but KvClient.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.DeleteRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, req)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedKvClient.DeleteCalls())
func (mock *KvClientMock) DeleteCalls() []struct {
	Ctx context.Context
	Req *memdx.DeleteRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.DeleteRequest
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// DeleteWithMeta calls DeleteWithMetaFunc.
func (mock *KvClientMock) DeleteWithMeta(ctx context.Context, req *memdx.DeleteWithMetaRequest) (*memdx.DeleteWithMetaResponse, error) {
	if mock.DeleteWithMetaFunc == nil {
		panic("KvClientMock.DeleteWithMetaFunc: method is nil but KvClient.DeleteWithMeta was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.DeleteWithMetaRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockDeleteWithMeta.Lock()
	mock.calls.DeleteWithMeta = append(mock.calls.DeleteWithMeta, callInfo)
	mock.lockDeleteWithMeta.Unlock()
	return mock.DeleteWithMetaFunc(ctx, req)
}

// DeleteWithMetaCalls gets all the calls that were made to DeleteWithMeta.
// Check the length with:
//
//	len(mockedKvClient.DeleteWithMetaCalls())
func (mock *KvClientMock) DeleteWithMetaCalls() []struct {
	Ctx context.Context
	Req *memdx.DeleteWithMetaRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.DeleteWithMetaRequest
	}
	mock.lockDeleteWithMeta.RLock()
	calls = mock.calls.DeleteWithMeta
	mock.lockDeleteWithMeta.RUnlock()
	return calls
}

// Dispatch calls DispatchFunc.
func (mock *KvClientMock) Dispatch(packet *memdx.Packet, dispatchCallback memdx.DispatchCallback) (memdx.PendingOp, error) {
	if mock.DispatchFunc == nil {
		panic("KvClientMock.DispatchFunc: method is nil but KvClient.Dispatch was just called")
	}
	callInfo := struct {
		Packet           *memdx.Packet
		DispatchCallback memdx.DispatchCallback
	}{
		Packet:           packet,
		DispatchCallback: dispatchCallback,
	}
	mock.lockDispatch.Lock()
	mock.calls.Dispatch = append(mock.calls.Dispatch, callInfo)
	mock.lockDispatch.Unlock()
	return mock.DispatchFunc(packet, dispatchCallback)
}

// DispatchCalls gets all the calls that were made to Dispatch.
// Check the length with:
//
//	len(mockedKvClient.DispatchCalls())
func (mock *KvClientMock) DispatchCalls() []struct {
	Packet           *memdx.Packet
	DispatchCallback memdx.DispatchCallback
} {
	var calls []struct {
		Packet           *memdx.Packet
		DispatchCallback memdx.DispatchCallback
	}
	mock.lockDispatch.RLock()
	calls = mock.calls.Dispatch
	mock.lockDispatch.RUnlock()
	return calls
}

// Get calls GetFunc.
func (mock *KvClientMock) Get(ctx context.Context, req *memdx.GetRequest) (*memdx.GetResponse, error) {
	if mock.GetFunc == nil {
		panic("KvClientMock.GetFunc: method is nil but KvClient.Get was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(ctx, req)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedKvClient.GetCalls())
func (mock *KvClientMock) GetCalls() []struct {
	Ctx context.Context
	Req *memdx.GetRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetRequest
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// GetAndLock calls GetAndLockFunc.
func (mock *KvClientMock) GetAndLock(ctx context.Context, req *memdx.GetAndLockRequest) (*memdx.GetAndLockResponse, error) {
	if mock.GetAndLockFunc == nil {
		panic("KvClientMock.GetAndLockFunc: method is nil but KvClient.GetAndLock was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetAndLockRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetAndLock.Lock()
	mock.calls.GetAndLock = append(mock.calls.GetAndLock, callInfo)
	mock.lockGetAndLock.Unlock()
	return mock.GetAndLockFunc(ctx, req)
}

// GetAndLockCalls gets all the calls that were made to GetAndLock.
// Check the length with:
//
//	len(mockedKvClient.GetAndLockCalls())
func (mock *KvClientMock) GetAndLockCalls() []struct {
	Ctx context.Context
	Req *memdx.GetAndLockRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetAndLockRequest
	}
	mock.lockGetAndLock.RLock()
	calls = mock.calls.GetAndLock
	mock.lockGetAndLock.RUnlock()
	return calls
}

// GetAndTouch calls GetAndTouchFunc.
func (mock *KvClientMock) GetAndTouch(ctx context.Context, req *memdx.GetAndTouchRequest) (*memdx.GetAndTouchResponse, error) {
	if mock.GetAndTouchFunc == nil {
		panic("KvClientMock.GetAndTouchFunc: method is nil but KvClient.GetAndTouch was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetAndTouchRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetAndTouch.Lock()
	mock.calls.GetAndTouch = append(mock.calls.GetAndTouch, callInfo)
	mock.lockGetAndTouch.Unlock()
	return mock.GetAndTouchFunc(ctx, req)
}

// GetAndTouchCalls gets all the calls that were made to GetAndTouch.
// Check the length with:
//
//	len(mockedKvClient.GetAndTouchCalls())
func (mock *KvClientMock) GetAndTouchCalls() []struct {
	Ctx context.Context
	Req *memdx.GetAndTouchRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetAndTouchRequest
	}
	mock.lockGetAndTouch.RLock()
	calls = mock.calls.GetAndTouch
	mock.lockGetAndTouch.RUnlock()
	return calls
}

// GetClusterConfig calls GetClusterConfigFunc.
func (mock *KvClientMock) GetClusterConfig(ctx context.Context, req *memdx.GetClusterConfigRequest) (*memdx.GetClusterConfigResponse, error) {
	if mock.GetClusterConfigFunc == nil {
		panic("KvClientMock.GetClusterConfigFunc: method is nil but KvClient.GetClusterConfig was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetClusterConfigRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetClusterConfig.Lock()
	mock.calls.GetClusterConfig = append(mock.calls.GetClusterConfig, callInfo)
	mock.lockGetClusterConfig.Unlock()
	return mock.GetClusterConfigFunc(ctx, req)
}

// GetClusterConfigCalls gets all the calls that were made to GetClusterConfig.
// Check the length with:
//
//	len(mockedKvClient.GetClusterConfigCalls())
func (mock *KvClientMock) GetClusterConfigCalls() []struct {
	Ctx context.Context
	Req *memdx.GetClusterConfigRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetClusterConfigRequest
	}
	mock.lockGetClusterConfig.RLock()
	calls = mock.calls.GetClusterConfig
	mock.lockGetClusterConfig.RUnlock()
	return calls
}

// GetCollectionID calls GetCollectionIDFunc.
func (mock *KvClientMock) GetCollectionID(ctx context.Context, req *memdx.GetCollectionIDRequest) (*memdx.GetCollectionIDResponse, error) {
	if mock.GetCollectionIDFunc == nil {
		panic("KvClientMock.GetCollectionIDFunc: method is nil but KvClient.GetCollectionID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetCollectionIDRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetCollectionID.Lock()
	mock.calls.GetCollectionID = append(mock.calls.GetCollectionID, callInfo)
	mock.lockGetCollectionID.Unlock()
	return mock.GetCollectionIDFunc(ctx, req)
}

// GetCollectionIDCalls gets all the calls that were made to GetCollectionID.
// Check the length with:
//
//	len(mockedKvClient.GetCollectionIDCalls())
func (mock *KvClientMock) GetCollectionIDCalls() []struct {
	Ctx context.Context
	Req *memdx.GetCollectionIDRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetCollectionIDRequest
	}
	mock.lockGetCollectionID.RLock()
	calls = mock.calls.GetCollectionID
	mock.lockGetCollectionID.RUnlock()
	return calls
}

// GetEx calls GetExFunc.
func (mock *KvClientMock) GetEx(ctx context.Context, req *memdx.GetExRequest) (*memdx.GetExResponse, error) {
	if mock.GetExFunc == nil {
		panic("KvClientMock.GetExFunc: method is nil but KvClient.GetEx was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetExRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetEx.Lock()
	mock.calls.GetEx = append(mock.calls.GetEx, callInfo)
	mock.lockGetEx.Unlock()
	return mock.GetExFunc(ctx, req)
}

// GetExCalls gets all the calls that were made to GetEx.
// Check the length with:
//
//	len(mockedKvClient.GetExCalls())
func (mock *KvClientMock) GetExCalls() []struct {
	Ctx context.Context
	Req *memdx.GetExRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetExRequest
	}
	mock.lockGetEx.RLock()
	calls = mock.calls.GetEx
	mock.lockGetEx.RUnlock()
	return calls
}

// GetMeta calls GetMetaFunc.
func (mock *KvClientMock) GetMeta(ctx context.Context, req *memdx.GetMetaRequest) (*memdx.GetMetaResponse, error) {
	if mock.GetMetaFunc == nil {
		panic("KvClientMock.GetMetaFunc: method is nil but KvClient.GetMeta was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetMetaRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetMeta.Lock()
	mock.calls.GetMeta = append(mock.calls.GetMeta, callInfo)
	mock.lockGetMeta.Unlock()
	return mock.GetMetaFunc(ctx, req)
}

// GetMetaCalls gets all the calls that were made to GetMeta.
// Check the length with:
//
//	len(mockedKvClient.GetMetaCalls())
func (mock *KvClientMock) GetMetaCalls() []struct {
	Ctx context.Context
	Req *memdx.GetMetaRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetMetaRequest
	}
	mock.lockGetMeta.RLock()
	calls = mock.calls.GetMeta
	mock.lockGetMeta.RUnlock()
	return calls
}

// GetRandom calls GetRandomFunc.
func (mock *KvClientMock) GetRandom(ctx context.Context, req *memdx.GetRandomRequest) (*memdx.GetRandomResponse, error) {
	if mock.GetRandomFunc == nil {
		panic("KvClientMock.GetRandomFunc: method is nil but KvClient.GetRandom was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetRandomRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetRandom.Lock()
	mock.calls.GetRandom = append(mock.calls.GetRandom, callInfo)
	mock.lockGetRandom.Unlock()
	return mock.GetRandomFunc(ctx, req)
}

// GetRandomCalls gets all the calls that were made to GetRandom.
// Check the length with:
//
//	len(mockedKvClient.GetRandomCalls())
func (mock *KvClientMock) GetRandomCalls() []struct {
	Ctx context.Context
	Req *memdx.GetRandomRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetRandomRequest
	}
	mock.lockGetRandom.RLock()
	calls = mock.calls.GetRandom
	mock.lockGetRandom.RUnlock()
	return calls
}

// GetReplica calls GetReplicaFunc.
func (mock *KvClientMock) GetReplica(ctx context.Context, req *memdx.GetReplicaRequest) (*memdx.GetReplicaResponse, error) {
	if mock.GetReplicaFunc == nil {
		panic("KvClientMock.GetReplicaFunc: method is nil but KvClient.GetReplica was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.GetReplicaRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockGetReplica.Lock()
	mock.calls.GetReplica = append(mock.calls.GetReplica, callInfo)
	mock.lockGetReplica.Unlock()
	return mock.GetReplicaFunc(ctx, req)
}

// GetReplicaCalls gets all the calls that were made to GetReplica.
// Check the length with:
//
//	len(mockedKvClient.GetReplicaCalls())
func (mock *KvClientMock) GetReplicaCalls() []struct {
	Ctx context.Context
	Req *memdx.GetReplicaRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.GetReplicaRequest
	}
	mock.lockGetReplica.RLock()
	calls = mock.calls.GetReplica
	mock.lockGetReplica.RUnlock()
	return calls
}

// HasFeature calls HasFeatureFunc.
func (mock *KvClientMock) HasFeature(feat memdx.HelloFeature) bool {
	if mock.HasFeatureFunc == nil {
		panic("KvClientMock.HasFeatureFunc: method is nil but KvClient.HasFeature was just called")
	}
	callInfo := struct {
		Feat memdx.HelloFeature
	}{
		Feat: feat,
	}
	mock.lockHasFeature.Lock()
	mock.calls.HasFeature = append(mock.calls.HasFeature, callInfo)
	mock.lockHasFeature.Unlock()
	return mock.HasFeatureFunc(feat)
}

// HasFeatureCalls gets all the calls that were made to HasFeature.
// Check the length with:
//
//	len(mockedKvClient.HasFeatureCalls())
func (mock *KvClientMock) HasFeatureCalls() []struct {
	Feat memdx.HelloFeature
} {
	var calls []struct {
		Feat memdx.HelloFeature
	}
	mock.lockHasFeature.RLock()
	calls = mock.calls.HasFeature
	mock.lockHasFeature.RUnlock()
	return calls
}

// Increment calls IncrementFunc.
func (mock *KvClientMock) Increment(ctx context.Context, req *memdx.IncrementRequest) (*memdx.IncrementResponse, error) {
	if mock.IncrementFunc == nil {
		panic("KvClientMock.IncrementFunc: method is nil but KvClient.Increment was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.IncrementRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockIncrement.Lock()
	mock.calls.Increment = append(mock.calls.Increment, callInfo)
	mock.lockIncrement.Unlock()
	return mock.IncrementFunc(ctx, req)
}

// IncrementCalls gets all the calls that were made to Increment.
// Check the length with:
//
//	len(mockedKvClient.IncrementCalls())
func (mock *KvClientMock) IncrementCalls() []struct {
	Ctx context.Context
	Req *memdx.IncrementRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.IncrementRequest
	}
	mock.lockIncrement.RLock()
	calls = mock.calls.Increment
	mock.lockIncrement.RUnlock()
	return calls
}

// LoadFactor calls LoadFactorFunc.
func (mock *KvClientMock) LoadFactor() float64 {
	if mock.LoadFactorFunc == nil {
		panic("KvClientMock.LoadFactorFunc: method is nil but KvClient.LoadFactor was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLoadFactor.Lock()
	mock.calls.LoadFactor = append(mock.calls.LoadFactor, callInfo)
	mock.lockLoadFactor.Unlock()
	return mock.LoadFactorFunc()
}

// LoadFactorCalls gets all the calls that were made to LoadFactor.
// Check the length with:
//
//	len(mockedKvClient.LoadFactorCalls())
func (mock *KvClientMock) LoadFactorCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLoadFactor.RLock()
	calls = mock.calls.LoadFactor
	mock.lockLoadFactor.RUnlock()
	return calls
}

// LocalAddr calls LocalAddrFunc.
func (mock *KvClientMock) LocalAddr() net.Addr {
	if mock.LocalAddrFunc == nil {
		panic("KvClientMock.LocalAddrFunc: method is nil but KvClient.LocalAddr was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLocalAddr.Lock()
	mock.calls.LocalAddr = append(mock.calls.LocalAddr, callInfo)
	mock.lockLocalAddr.Unlock()
	return mock.LocalAddrFunc()
}

// LocalAddrCalls gets all the calls that were made to LocalAddr.
// Check the length with:
//
//	len(mockedKvClient.LocalAddrCalls())
func (mock *KvClientMock) LocalAddrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLocalAddr.RLock()
	calls = mock.calls.LocalAddr
	mock.lockLocalAddr.RUnlock()
	return calls
}

// LookupIn calls LookupInFunc.
func (mock *KvClientMock) LookupIn(ctx context.Context, req *memdx.LookupInRequest) (*memdx.LookupInResponse, error) {
	if mock.LookupInFunc == nil {
		panic("KvClientMock.LookupInFunc: method is nil but KvClient.LookupIn was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.LookupInRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockLookupIn.Lock()
	mock.calls.LookupIn = append(mock.calls.LookupIn, callInfo)
	mock.lockLookupIn.Unlock()
	return mock.LookupInFunc(ctx, req)
}

// LookupInCalls gets all the calls that were made to LookupIn.
// Check the length with:
//
//	len(mockedKvClient.LookupInCalls())
func (mock *KvClientMock) LookupInCalls() []struct {
	Ctx context.Context
	Req *memdx.LookupInRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.LookupInRequest
	}
	mock.lockLookupIn.RLock()
	calls = mock.calls.LookupIn
	mock.lockLookupIn.RUnlock()
	return calls
}

// MutateIn calls MutateInFunc.
func (mock *KvClientMock) MutateIn(ctx context.Context, req *memdx.MutateInRequest) (*memdx.MutateInResponse, error) {
	if mock.MutateInFunc == nil {
		panic("KvClientMock.MutateInFunc: method is nil but KvClient.MutateIn was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.MutateInRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockMutateIn.Lock()
	mock.calls.MutateIn = append(mock.calls.MutateIn, callInfo)
	mock.lockMutateIn.Unlock()
	return mock.MutateInFunc(ctx, req)
}

// MutateInCalls gets all the calls that were made to MutateIn.
// Check the length with:
//
//	len(mockedKvClient.MutateInCalls())
func (mock *KvClientMock) MutateInCalls() []struct {
	Ctx context.Context
	Req *memdx.MutateInRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.MutateInRequest
	}
	mock.lockMutateIn.RLock()
	calls = mock.calls.MutateIn
	mock.lockMutateIn.RUnlock()
	return calls
}

// Prepend calls PrependFunc.
func (mock *KvClientMock) Prepend(ctx context.Context, req *memdx.PrependRequest) (*memdx.PrependResponse, error) {
	if mock.PrependFunc == nil {
		panic("KvClientMock.PrependFunc: method is nil but KvClient.Prepend was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.PrependRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockPrepend.Lock()
	mock.calls.Prepend = append(mock.calls.Prepend, callInfo)
	mock.lockPrepend.Unlock()
	return mock.PrependFunc(ctx, req)
}

// PrependCalls gets all the calls that were made to Prepend.
// Check the length with:
//
//	len(mockedKvClient.PrependCalls())
func (mock *KvClientMock) PrependCalls() []struct {
	Ctx context.Context
	Req *memdx.PrependRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.PrependRequest
	}
	mock.lockPrepend.RLock()
	calls = mock.calls.Prepend
	mock.lockPrepend.RUnlock()
	return calls
}

// RangeScanCancel calls RangeScanCancelFunc.
func (mock *KvClientMock) RangeScanCancel(ctx context.Context, req *memdx.RangeScanCancelRequest) (*memdx.RangeScanCancelResponse, error) {
	if mock.RangeScanCancelFunc == nil {
		panic("KvClientMock.RangeScanCancelFunc: method is nil but KvClient.RangeScanCancel was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.RangeScanCancelRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockRangeScanCancel.Lock()
	mock.calls.RangeScanCancel = append(mock.calls.RangeScanCancel, callInfo)
	mock.lockRangeScanCancel.Unlock()
	return mock.RangeScanCancelFunc(ctx, req)
}

// RangeScanCancelCalls gets all the calls that were made to RangeScanCancel.
// Check the length with:
//
//	len(mockedKvClient.RangeScanCancelCalls())
func (mock *KvClientMock) RangeScanCancelCalls() []struct {
	Ctx context.Context
	Req *memdx.RangeScanCancelRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.RangeScanCancelRequest
	}
	mock.lockRangeScanCancel.RLock()
	calls = mock.calls.RangeScanCancel
	mock.lockRangeScanCancel.RUnlock()
	return calls
}

// RangeScanContinue calls RangeScanContinueFunc.
func (mock *KvClientMock) RangeScanContinue(ctx context.Context, req *memdx.RangeScanContinueRequest, dataCb func(*memdx.RangeScanDataResponse) error) (*memdx.RangeScanActionResponse, error) {
	if mock.RangeScanContinueFunc == nil {
		panic("KvClientMock.RangeScanContinueFunc: method is nil but KvClient.RangeScanContinue was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Req    *memdx.RangeScanContinueRequest
		DataCb func(*memdx.RangeScanDataResponse) error
	}{
		Ctx:    ctx,
		Req:    req,
		DataCb: dataCb,
	}
	mock.lockRangeScanContinue.Lock()
	mock.calls.RangeScanContinue = append(mock.calls.RangeScanContinue, callInfo)
	mock.lockRangeScanContinue.Unlock()
	return mock.RangeScanContinueFunc(ctx, req, dataCb)
}

// RangeScanContinueCalls gets all the calls that were made to RangeScanContinue.
// Check the length with:
//
//	len(mockedKvClient.RangeScanContinueCalls())
func (mock *KvClientMock) RangeScanContinueCalls() []struct {
	Ctx    context.Context
	Req    *memdx.RangeScanContinueRequest
	DataCb func(*memdx.RangeScanDataResponse) error
} {
	var calls []struct {
		Ctx    context.Context
		Req    *memdx.RangeScanContinueRequest
		DataCb func(*memdx.RangeScanDataResponse) error
	}
	mock.lockRangeScanContinue.RLock()
	calls = mock.calls.RangeScanContinue
	mock.lockRangeScanContinue.RUnlock()
	return calls
}

// RangeScanCreate calls RangeScanCreateFunc.
func (mock *KvClientMock) RangeScanCreate(ctx context.Context, req *memdx.RangeScanCreateRequest) (*memdx.RangeScanCreateResponse, error) {
	if mock.RangeScanCreateFunc == nil {
		panic("KvClientMock.RangeScanCreateFunc: method is nil but KvClient.RangeScanCreate was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.RangeScanCreateRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockRangeScanCreate.Lock()
	mock.calls.RangeScanCreate = append(mock.calls.RangeScanCreate, callInfo)
	mock.lockRangeScanCreate.Unlock()
	return mock.RangeScanCreateFunc(ctx, req)
}

// RangeScanCreateCalls gets all the calls that were made to RangeScanCreate.
// Check the length with:
//
//	len(mockedKvClient.RangeScanCreateCalls())
func (mock *KvClientMock) RangeScanCreateCalls() []struct {
	Ctx context.Context
	Req *memdx.RangeScanCreateRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.RangeScanCreateRequest
	}
	mock.lockRangeScanCreate.RLock()
	calls = mock.calls.RangeScanCreate
	mock.lockRangeScanCreate.RUnlock()
	return calls
}

// Reconfigure calls ReconfigureFunc.
func (mock *KvClientMock) Reconfigure(config *KvClientConfig, cb func(error)) error {
	if mock.ReconfigureFunc == nil {
		panic("KvClientMock.ReconfigureFunc: method is nil but KvClient.Reconfigure was just called")
	}
	callInfo := struct {
		Config *KvClientConfig
		Cb     func(error)
	}{
		Config: config,
		Cb:     cb,
	}
	mock.lockReconfigure.Lock()
	mock.calls.Reconfigure = append(mock.calls.Reconfigure, callInfo)
	mock.lockReconfigure.Unlock()
	return mock.ReconfigureFunc(config, cb)
}

// ReconfigureCalls gets all the calls that were made to Reconfigure.
// Check the length with:
//
//	len(mockedKvClient.ReconfigureCalls())
func (mock *KvClientMock) ReconfigureCalls() []struct {
	Config *KvClientConfig
	Cb     func(error)
} {
	var calls []struct {
		Config *KvClientConfig
		Cb     func(error)
	}
	mock.lockReconfigure.RLock()
	calls = mock.calls.Reconfigure
	mock.lockReconfigure.RUnlock()
	return calls
}

// RemoteAddr calls RemoteAddrFunc.
func (mock *KvClientMock) RemoteAddr() net.Addr {
	if mock.RemoteAddrFunc == nil {
		panic("KvClientMock.RemoteAddrFunc: method is nil but KvClient.RemoteAddr was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRemoteAddr.Lock()
	mock.calls.RemoteAddr = append(mock.calls.RemoteAddr, callInfo)
	mock.lockRemoteAddr.Unlock()
	return mock.RemoteAddrFunc()
}

// RemoteAddrCalls gets all the calls that were made to RemoteAddr.
// Check the length with:
//
//	len(mockedKvClient.RemoteAddrCalls())
func (mock *KvClientMock) RemoteAddrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRemoteAddr.RLock()
	calls = mock.calls.RemoteAddr
	mock.lockRemoteAddr.RUnlock()
	return calls
}

// RemoteHostname calls RemoteHostnameFunc.
func (mock *KvClientMock) RemoteHostname() string {
	if mock.RemoteHostnameFunc == nil {
		panic("KvClientMock.RemoteHostnameFunc: method is nil but KvClient.RemoteHostname was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRemoteHostname.Lock()
	mock.calls.RemoteHostname = append(mock.calls.RemoteHostname, callInfo)
	mock.lockRemoteHostname.Unlock()
	return mock.RemoteHostnameFunc()
}

// RemoteHostnameCalls gets all the calls that were made to RemoteHostname.
// Check the length with:
//
//	len(mockedKvClient.RemoteHostnameCalls())
func (mock *KvClientMock) RemoteHostnameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRemoteHostname.RLock()
	calls = mock.calls.RemoteHostname
	mock.lockRemoteHostname.RUnlock()
	return calls
}

// Replace calls ReplaceFunc.
func (mock *KvClientMock) Replace(ctx context.Context, req *memdx.ReplaceRequest) (*memdx.ReplaceResponse, error) {
	if mock.ReplaceFunc == nil {
		panic("KvClientMock.ReplaceFunc: method is nil but KvClient.Replace was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.ReplaceRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockReplace.Lock()
	mock.calls.Replace = append(mock.calls.Replace, callInfo)
	mock.lockReplace.Unlock()
	return mock.ReplaceFunc(ctx, req)
}

// ReplaceCalls gets all the calls that were made to Replace.
// Check the length with:
//
//	len(mockedKvClient.ReplaceCalls())
func (mock *KvClientMock) ReplaceCalls() []struct {
	Ctx context.Context
	Req *memdx.ReplaceRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.ReplaceRequest
	}
	mock.lockReplace.RLock()
	calls = mock.calls.Replace
	mock.lockReplace.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *KvClientMock) Set(ctx context.Context, req *memdx.SetRequest) (*memdx.SetResponse, error) {
	if mock.SetFunc == nil {
		panic("KvClientMock.SetFunc: method is nil but KvClient.Set was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.SetRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	return mock.SetFunc(ctx, req)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//
//	len(mockedKvClient.SetCalls())
func (mock *KvClientMock) SetCalls() []struct {
	Ctx context.Context
	Req *memdx.SetRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.SetRequest
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}

// SetWithMeta calls SetWithMetaFunc.
func (mock *KvClientMock) SetWithMeta(ctx context.Context, req *memdx.SetWithMetaRequest) (*memdx.SetWithMetaResponse, error) {
	if mock.SetWithMetaFunc == nil {
		panic("KvClientMock.SetWithMetaFunc: method is nil but KvClient.SetWithMeta was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.SetWithMetaRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockSetWithMeta.Lock()
	mock.calls.SetWithMeta = append(mock.calls.SetWithMeta, callInfo)
	mock.lockSetWithMeta.Unlock()
	return mock.SetWithMetaFunc(ctx, req)
}

// SetWithMetaCalls gets all the calls that were made to SetWithMeta.
// Check the length with:
//
//	len(mockedKvClient.SetWithMetaCalls())
func (mock *KvClientMock) SetWithMetaCalls() []struct {
	Ctx context.Context
	Req *memdx.SetWithMetaRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.SetWithMetaRequest
	}
	mock.lockSetWithMeta.RLock()
	calls = mock.calls.SetWithMeta
	mock.lockSetWithMeta.RUnlock()
	return calls
}

// Stats calls StatsFunc.
func (mock *KvClientMock) Stats(ctx context.Context, req *memdx.StatsRequest, dataCb func(*memdx.StatsDataResponse) error) (*memdx.StatsActionResponse, error) {
	if mock.StatsFunc == nil {
		panic("KvClientMock.StatsFunc: method is nil but KvClient.Stats was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Req    *memdx.StatsRequest
		DataCb func(*memdx.StatsDataResponse) error
	}{
		Ctx:    ctx,
		Req:    req,
		DataCb: dataCb,
	}
	mock.lockStats.Lock()
	mock.calls.Stats = append(mock.calls.Stats, callInfo)
	mock.lockStats.Unlock()
	return mock.StatsFunc(ctx, req, dataCb)
}

// StatsCalls gets all the calls that were made to Stats.
// Check the length with:
//
//	len(mockedKvClient.StatsCalls())
func (mock *KvClientMock) StatsCalls() []struct {
	Ctx    context.Context
	Req    *memdx.StatsRequest
	DataCb func(*memdx.StatsDataResponse) error
} {
	var calls []struct {
		Ctx    context.Context
		Req    *memdx.StatsRequest
		DataCb func(*memdx.StatsDataResponse) error
	}
	mock.lockStats.RLock()
	calls = mock.calls.Stats
	mock.lockStats.RUnlock()
	return calls
}

// Touch calls TouchFunc.
func (mock *KvClientMock) Touch(ctx context.Context, req *memdx.TouchRequest) (*memdx.TouchResponse, error) {
	if mock.TouchFunc == nil {
		panic("KvClientMock.TouchFunc: method is nil but KvClient.Touch was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.TouchRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockTouch.Lock()
	mock.calls.Touch = append(mock.calls.Touch, callInfo)
	mock.lockTouch.Unlock()
	return mock.TouchFunc(ctx, req)
}

// TouchCalls gets all the calls that were made to Touch.
// Check the length with:
//
//	len(mockedKvClient.TouchCalls())
func (mock *KvClientMock) TouchCalls() []struct {
	Ctx context.Context
	Req *memdx.TouchRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.TouchRequest
	}
	mock.lockTouch.RLock()
	calls = mock.calls.Touch
	mock.lockTouch.RUnlock()
	return calls
}

// Unlock calls UnlockFunc.
func (mock *KvClientMock) Unlock(ctx context.Context, req *memdx.UnlockRequest) (*memdx.UnlockResponse, error) {
	if mock.UnlockFunc == nil {
		panic("KvClientMock.UnlockFunc: method is nil but KvClient.Unlock was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Req *memdx.UnlockRequest
	}{
		Ctx: ctx,
		Req: req,
	}
	mock.lockUnlock.Lock()
	mock.calls.Unlock = append(mock.calls.Unlock, callInfo)
	mock.lockUnlock.Unlock()
	return mock.UnlockFunc(ctx, req)
}

// UnlockCalls gets all the calls that were made to Unlock.
// Check the length with:
//
//	len(mockedKvClient.UnlockCalls())
func (mock *KvClientMock) UnlockCalls() []struct {
	Ctx context.Context
	Req *memdx.UnlockRequest
} {
	var calls []struct {
		Ctx context.Context
		Req *memdx.UnlockRequest
	}
	mock.lockUnlock.RLock()
	calls = mock.calls.Unlock
	mock.lockUnlock.RUnlock()
	return calls
}

// Ensure, that MemdxClientMock does implement MemdxClient.
// If this is not the case, regenerate this file with moq.
var _ MemdxClient = &MemdxClientMock{}

// MemdxClientMock is a mock implementation of MemdxClient.
//
//	func TestSomethingThatUsesMemdxClient(t *testing.T) {
//
//		// make and configure a mocked MemdxClient
//		mockedMemdxClient := &MemdxClientMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			DispatchFunc: func(packet *memdx.Packet, dispatchCallback memdx.DispatchCallback) (memdx.PendingOp, error) {
//				panic("mock out the Dispatch method")
//			},
//			LocalAddrFunc: func() net.Addr {
//				panic("mock out the LocalAddr method")
//			},
//			RemoteAddrFunc: func() net.Addr {
//				panic("mock out the RemoteAddr method")
//			},
//			WritePacketFunc: func(pak *memdx.Packet) error {
//				panic("mock out the WritePacket method")
//			},
//		}
//
//		// use mockedMemdxClient in code that requires MemdxClient
//		// and then make assertions.
//
//	}
type MemdxClientMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// DispatchFunc mocks the Dispatch method.
	DispatchFunc func(packet *memdx.Packet, dispatchCallback memdx.DispatchCallback) (memdx.PendingOp, error)

	// LocalAddrFunc mocks the LocalAddr method.
	LocalAddrFunc func() net.Addr

	// RemoteAddrFunc mocks the RemoteAddr method.
	RemoteAddrFunc func() net.Addr

	// WritePacketFunc mocks the WritePacket method.
	WritePacketFunc func(pak *memdx.Packet) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Dispatch holds details about calls to the Dispatch method.
		Dispatch []struct {
			// Packet is the packet argument value.
			Packet *memdx.Packet
			// DispatchCallback is the dispatchCallback argument value.
			DispatchCallback memdx.DispatchCallback
		}
		// LocalAddr holds details about calls to the LocalAddr method.
		LocalAddr []struct {
		}
		// RemoteAddr holds details about calls to the RemoteAddr method.
		RemoteAddr []struct {
		}
		// WritePacket holds details about calls to the WritePacket method.
		WritePacket []struct {
			// Pak is the pak argument value.
			Pak *memdx.Packet
		}
	}
	lockClose       sync.RWMutex
	lockDispatch    sync.RWMutex
	lockLocalAddr   sync.RWMutex
	lockRemoteAddr  sync.RWMutex
	lockWritePacket sync.RWMutex
}

// Close calls CloseFunc.
func (mock *MemdxClientMock) Close() error {
	if mock.CloseFunc == nil {
		panic("MemdxClientMock.CloseFunc: method is nil but MemdxClient.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedMemdxClient.CloseCalls())
func (mock *MemdxClientMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Dispatch calls DispatchFunc.
func (mock *MemdxClientMock) Dispatch(packet *memdx.Packet, dispatchCallback memdx.DispatchCallback) (memdx.PendingOp, error) {
	if mock.DispatchFunc == nil {
		panic("MemdxClientMock.DispatchFunc: method is nil but MemdxClient.Dispatch was just called")
	}
	callInfo := struct {
		Packet           *memdx.Packet
		DispatchCallback memdx.DispatchCallback
	}{
		Packet:           packet,
		DispatchCallback: dispatchCallback,
	}
	mock.lockDispatch.Lock()
	mock.calls.Dispatch = append(mock.calls.Dispatch, callInfo)
	mock.lockDispatch.Unlock()
	return mock.DispatchFunc(packet, dispatchCallback)
}

// DispatchCalls gets all the calls that were made to Dispatch.
// Check the length with:
//
//	len(mockedMemdxClient.DispatchCalls())
func (mock *MemdxClientMock) DispatchCalls() []struct {
	Packet           *memdx.Packet
	DispatchCallback memdx.DispatchCallback
} {
	var calls []struct {
		Packet           *memdx.Packet
		DispatchCallback memdx.DispatchCallback
	}
	mock.lockDispatch.RLock()
	calls = mock.calls.Dispatch
	mock.lockDispatch.RUnlock()
	return calls
}

// LocalAddr calls LocalAddrFunc.
func (mock *MemdxClientMock) LocalAddr() net.Addr {
	if mock.LocalAddrFunc == nil {
		panic("MemdxClientMock.LocalAddrFunc: method is nil but MemdxClient.LocalAddr was just called")
	}
	callInfo := struct {
	}{}
	mock.lockLocalAddr.Lock()
	mock.calls.LocalAddr = append(mock.calls.LocalAddr, callInfo)
	mock.lockLocalAddr.Unlock()
	return mock.LocalAddrFunc()
}

// LocalAddrCalls gets all the calls that were made to LocalAddr.
// Check the length with:
//
//	len(mockedMemdxClient.LocalAddrCalls())
func (mock *MemdxClientMock) LocalAddrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockLocalAddr.RLock()
	calls = mock.calls.LocalAddr
	mock.lockLocalAddr.RUnlock()
	return calls
}

// RemoteAddr calls RemoteAddrFunc.
func (mock *MemdxClientMock) RemoteAddr() net.Addr {
	if mock.RemoteAddrFunc == nil {
		panic("MemdxClientMock.RemoteAddrFunc: method is nil but MemdxClient.RemoteAddr was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRemoteAddr.Lock()
	mock.calls.RemoteAddr = append(mock.calls.RemoteAddr, callInfo)
	mock.lockRemoteAddr.Unlock()
	return mock.RemoteAddrFunc()
}

// RemoteAddrCalls gets all the calls that were made to RemoteAddr.
// Check the length with:
//
//	len(mockedMemdxClient.RemoteAddrCalls())
func (mock *MemdxClientMock) RemoteAddrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRemoteAddr.RLock()
	calls = mock.calls.RemoteAddr
	mock.lockRemoteAddr.RUnlock()
	return calls
}

// WritePacket calls WritePacketFunc.
func (mock *MemdxClientMock) WritePacket(pak *memdx.Packet) error {
	if mock.WritePacketFunc == nil {
		panic("MemdxClientMock.WritePacketFunc: method is nil but MemdxClient.WritePacket was just called")
	}
	callInfo := struct {
		Pak *memdx.Packet
	}{
		Pak: pak,
	}
	mock.lockWritePacket.Lock()
	mock.calls.WritePacket = append(mock.calls.WritePacket, callInfo)
	mock.lockWritePacket.Unlock()
	return mock.WritePacketFunc(pak)
}

// WritePacketCalls gets all the calls that were made to WritePacket.
// Check the length with:
//
//	len(mockedMemdxClient.WritePacketCalls())
func (mock *MemdxClientMock) WritePacketCalls() []struct {
	Pak *memdx.Packet
} {
	var calls []struct {
		Pak *memdx.Packet
	}
	mock.lockWritePacket.RLock()
	calls = mock.calls.WritePacket
	mock.lockWritePacket.RUnlock()
	return calls
}
